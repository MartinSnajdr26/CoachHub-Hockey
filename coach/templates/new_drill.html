{% extends "base.html" %}
{% block title %}NovÃ© cviÄenÃ­{% endblock %}

{% block content %}
<div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
  <h1>NovÃ© cviÄenÃ­</h1>
  <button type="button" class="help-btn" data-help="new_drill" data-help-src="help-newdrill"><span class="ico">i</span> NÃ¡povÄ›da</button>
</div>
<div id="help-newdrill" style="display:none;">
  <h3>Jak kreslit novÃ© cviÄenÃ­</h3>
  <ul>
    <li>Vyber nÃ¡stroj v toolbaru (pohyb, nahrÃ¡vka, ikonyâ€¦); Å¥ukni do plochy a kresli.</li>
    <li>â€œSouÄasnÄ›â€ seskupÃ­ kroky do jednÃ© sekvence; barvy F/D lze mÄ›nit.</li>
    <li>UloÅ¾it: obrÃ¡zek + animace (path_data) se uloÅ¾Ã­ k cviÄenÃ­.</li>
  </ul>
</div>

<form id="newDrillForm" method="POST" action="{{ url_for('save_drill') }}">
    <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
    <p><b>NÃ¡zev:</b> <input type="text" name="name" required></p>
    <p><b>Kategorie:</b> <input type="text" name="category" required></p>
    <p><b>Popis:</b><br><textarea name="description" rows="3" style="width:100%;"></textarea></p>
    <p><b>Doba (min):</b> <input type="number" name="duration" min="1"></p>

    <!-- ğŸš Slider na velikost rink canvasu -->
    <p>
        Velikost plochy:
        <input type="range" id="canvasSize" min="600" max="2000" value="1400" step="50">
    </p>

    <!-- Toolbar + canvas -->
    <div class="draw-container">
        <div class="toolbar-toggle-desktop">
          <button type="button" id="btnToggleToolbarDesktop">SkrÃ½t nÃ¡stroje</button>
        </div>
        <div class="toolbar-toggle-mobile">
          <button type="button" id="btnToggleToolbarMobile">SkrÃ½t nÃ¡stroje</button>
        </div>
        <div class="toolbar toolbar--compact" id="toolbar">
            <style>
              .toolbar{ display:flex; flex-wrap:wrap; gap:10px; align-items:flex-start; background: var(--brand-primary, #d4c76f); padding:8px; border-radius:12px; }
              .toolbar .tool-group{ display:flex; align-items:center; gap:8px; flex-wrap:wrap; background:transparent; padding:6px 8px; border-radius:10px; }
              .toolbar .group-title{ font-weight:700; font-size:12px; opacity:.7; margin-right:6px; }
              .toolbar .btn-tool{ min-width:36px; height:36px; padding:4px 8px; border:1px solid var(--brand-secondary, #000); background:#fff; color: var(--brand-secondary, #000); border-radius:8px; cursor:pointer; display:inline-flex; align-items:center; justify-content:center; gap:6px; transition: background .15s ease, color .15s ease, box-shadow .15s ease; }
              .toolbar .btn-tool .ic{ font-size:20px; line-height:1; }
              .toolbar .btn-tool .lbl{ font-size:12px; }
              .toolbar .btn-tool:hover{ background: color-mix(in srgb, #fff 70%, var(--brand-primary, #d4c76f) 30%); }
              .toolbar .btn-tool.is-active{ background: color-mix(in srgb, var(--brand-primary, #d4c76f) 25%, #ffffff); box-shadow: inset 0 0 0 2px var(--brand-secondary, #000); }
              .toolbar--compact .group-title{ display:none; }
              .toolbar--compact .btn-tool{ width:36px; min-width:36px; padding:0; }
              .toolbar--compact .btn-tool .lbl{ display:none; }
              .toolbar .toggle-label{ padding:6px 8px; border-radius:6px; background: color-mix(in srgb, var(--brand-primary, #d4c76f) 25%, white); color: var(--brand-secondary, #000); cursor:pointer; font-size:14px; }
              .toolbar .toggle-label.active { background: #3bb273; color:#fff; }
              .toolbar .toggle-label.off { background: #c44747; color:#fff; }
              .toolbar .pill { display:inline-block; padding:4px 10px; border-radius:999px; font-size:13px; margin-top:6px; }
              .toolbar .pill.on { background: #3bb273; color:#fff; }
              .toolbar .pill.off { background: #c44747; color:#fff; }
            </style>
            <div class="tool-group">
              <span class="group-title">ZobrazenÃ­</span>
              <label class="toggle-label" style="display:flex; align-items:center; gap:6px;" title="KompaktnÃ­ reÅ¾im toolbaru (ikony)">
                <input type="checkbox" id="compactToggle" checked> <span class="lbl">KompaktnÃ­ reÅ¾im</span>
              </label>
            </div>
            <div class="tool-group">
              <span class="group-title">Pohyb</span>
              <button type="button" class="btn-tool" data-tool="straight" title="Pohyb bez puku"><span class="ic">â†’</span><span class="lbl">Pohyb bez puku (rovnÄ›)</span></button>
              <button type="button" class="btn-tool" data-tool="curve" title="Pohyb bez puku (volnÃ½)"><span class="ic">ã€°</span><span class="lbl">Pohyb bez puku</span></button>
              <button type="button" class="btn-tool" data-tool="wave" title="Pohyb s pukem"><span class="ic">â‰ˆ</span><span class="lbl">JÃ­zda s pukem</span></button>
              <button type="button" class="btn-tool" data-tool="zigzag" title="JÃ­zda vzad"><span class="ic">â†¯</span><span class="lbl">JÃ­zda vzad</span></button>
            </div>
            <div class="tool-group">
              <span class="group-title">Akce s pukem</span>
              <button type="button" class="btn-tool" data-tool="dotted" title="NahrÃ¡vka"><span class="ic">â‹¯â†’</span><span class="lbl">NahrÃ¡vka</span></button>
              <button type="button" class="btn-tool" data-tool="double" title="StÅ™ela"><span class="ic">â—â†’</span><span class="lbl">StÅ™ela</span></button>
            </div>
            <div class="tool-group">
              <span class="group-title">Ikony/Objekty</span>
              <button type="button" class="btn-tool" data-tool="circleF" title="ÃštoÄnÃ­k (F)"><span class="ic">ğŸ”µ</span><span class="lbl">F</span></button>
              <button type="button" class="btn-tool" data-tool="circleD" title="ObrÃ¡nce (D)"><span class="ic">ğŸ”º</span><span class="lbl">D</span></button>
              <button type="button" class="btn-tool" data-tool="circleG" title="GÃ³lman (G)"><span class="ic">âš«</span><span class="lbl">G</span></button>
              <button type="button" class="btn-tool" data-tool="triangle" title="TrojÃºhelnÃ­k"><span class="ic">ğŸ”»</span><span class="lbl">KuÅ¾el</span></button>
              <button type="button" class="btn-tool" data-tool="puck" title="Puk"><span class="ic">â—</span><span class="lbl">Puk</span></button>
              <button type="button" class="btn-tool" data-tool="pucks" title="ZÃ¡soba pukÅ¯"><span class="ic">â—â—</span><span class="lbl">Puky</span></button>
              <button type="button" class="btn-tool" data-tool="cone" title="KuÅ¾el"><span class="ic">â–²</span><span class="lbl">KuÅ¾el</span></button>
              <button type="button" class="btn-tool" data-tool="goal" id="btnToolGoal" title="Branka" draggable="true"><span class="ic">ğŸ—‚</span><span class="lbl">Branka</span></button>
              <div id="goalRotationPicker" style="display:none; gap:6px; align-items:center; padding:6px; border:1px solid var(--brand-secondary, #000); border-radius:8px; background:#fff;">
                <span class="group-title" style="margin-right:0;">Orientace:</span>
                <button type="button" class="btn-tool" data-rot="0" title="0Â°" style="width:36px; min-width:36px; padding:0; overflow:hidden;">
                  <img src="/static/branka.png" alt="branka 0" draggable="true" style="width:100%; height:100%; object-fit:contain; transform: rotate(0deg); transform-origin:center;">
                </button>
                <button type="button" class="btn-tool" data-rot="90" title="90Â°" style="width:36px; min-width:36px; padding:0; overflow:hidden;">
                  <img src="/static/branka.png" alt="branka 90" draggable="true" style="width:100%; height:100%; object-fit:contain; transform: rotate(90deg); transform-origin:center;">
                </button>
                <button type="button" class="btn-tool" data-rot="180" title="180Â°" style="width:36px; min-width:36px; padding:0; overflow:hidden;">
                  <img src="/static/branka.png" alt="branka 180" draggable="true" style="width:100%; height:100%; object-fit:contain; transform: rotate(180deg); transform-origin:center;">
                </button>
                <button type="button" class="btn-tool" data-rot="270" title="270Â°" style="width:36px; min-width:36px; padding:0; overflow:hidden;">
                  <img src="/static/branka.png" alt="branka 270" draggable="true" style="width:100%; height:100%; object-fit:contain; transform: rotate(270deg); transform-origin:center;">
                </button>
              </div>
              <label title="Barva ÃºtoÄnÃ­ka (F)" style="display:inline-flex; align-items:center; gap:6px; font-size:12px;">
                <span class="lbl">F</span>
                <input type="color" id="colorF" value="#0000ff" style="width:28px; height:28px; padding:0; border:none; background:transparent;">
              </label>
              <label title="Barva obrÃ¡nce (D)" style="display:inline-flex; align-items:center; gap:6px; font-size:12px;">
                <span class="lbl">D</span>
                <input type="color" id="colorD" value="#ff0000" style="width:28px; height:28px; padding:0; border:none; background:transparent;">
              </label>
            </div>
            <div class="tool-group">
              <span class="group-title">Sync</span>
              <div style="margin-top:0; font-size:14px; display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
                 <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
                     <label id="lblSyncStart" class="toggle-label off" style="display:flex; align-items:center; gap:6px;" title="Spustit souÄasnÃ½ start hrÃ¡ÄÅ¯ (Play)">
                         <input type="checkbox" id="syncStart"> <span class="ic">â–¶</span> <span class="lbl">ZaÄÃ­t synchronizaci hrÃ¡ÄÅ¯</span>
                     </label>
                     <label id="lblSyncEnd" class="toggle-label off" style="display:flex; align-items:center; gap:6px;" title="UkonÄit souÄasnÃ½ start hrÃ¡ÄÅ¯ (Stop)">
                         <input type="checkbox" id="syncEnd"> <span class="ic">â¹</span> <span class="lbl">UkonÄit synchronizaci hrÃ¡ÄÅ¯</span>
                     </label>
                     <span id="syncStatus" class="pill off">SouÄasnÄ›: vypnuto</span>
                 </div>
                 <div class="hint-invert" style="width:100%; font-size:16px; opacity:0.95; color: var(--brand-secondary, #000);">Po â€ZaÄÃ­tâ€œ budou vÅ¡echny nÃ¡sledujÃ­cÃ­ hrÃ¡ÄskÃ© tahy (vÄetnÄ› jÃ­zdy s pukem) spuÅ¡tÄ›ny souÄasnÄ›. â€UkonÄitâ€œ uzavÅ™e skupinu; dalÅ¡Ã­ tahy uÅ¾ pojedou opÄ›t sekvenÄnÄ›, dokud znovu nedÃ¡te â€ZaÄÃ­tâ€œ.</div>
              </div>
            </div>
        </div>

        <canvas id="board" class="rink-canvas"></canvas>
    </div>

    <input type="hidden" name="image_data" id="image_data">
    <input type="hidden" name="path_data" id="path_data">

    <p style="margin-top:15px;">
        <button type="button" class="btn-clear">ğŸ§¹ Vymazat</button>
        <button type="button" class="btn-undo">â†©ï¸ ZpÄ›t</button>
        {% if is_coach %}
            <button type="submit" class="btn-save-drill">ğŸ’¾ UloÅ¾it cviÄenÃ­</button>
        {% else %}
            <button type="button" disabled title="UloÅ¾enÃ­ je dostupnÃ© jen pro trenÃ©ra">ğŸ’¾ UloÅ¾it cviÄenÃ­</button>
        {% endif %}
    </p>
</form>
    <p style="margin-top:20px;"><a href="{{ url_for('drills') }}">â† ZpÄ›t na seznam cviÄenÃ­</a></p>

    <!-- Floating action button (mobile) to toggle toolbar visibility) -->
    <div class="fab-toolbar" aria-hidden="false">
      <button type="button" id="fabToggleToolbar" aria-label="Zobrazit/SkrÃ½t nÃ¡stroje">ğŸ› </button>
    </div>

<script nonce="{{ csp_nonce }}">
let canvas = document.getElementById("board");
let ctx = canvas.getContext("2d");
let currentTool = "straight";
let drawing = false;
let _placedImmediate = false; // guard to skip mouseup after instant placement
let startX, startY;
let pathPoints = [];
let history = [];
let drawData = []; // pro uloÅ¾enÃ­ cesty
let dataHistory = [];
let syncActive = false; // bÄ›Å¾Ã­cÃ­ skupina hrÃ¡ÄskÃ½ch tahÅ¯
let syncCounter = 0;    // identifikÃ¡tor skupiny

let rink = new Image();
rink.src = "/static/rink.png";
let manualSize = false;
// Branka image
let goalImg = new Image();
goalImg.src = "/static/branka.png";
let currentGoalRotation = 0; // degrees: 0/90/180/270
try { goalImg.onload = () => { try { redrawAll(); } catch(_){} }; } catch(_){}
function containerWidth(){
  try { return Math.max(600, Math.floor(canvas.parentElement.clientWidth)); } catch(_) { return 600; }
}
rink.onload = () => { resizeCanvas(containerWidth()); saveState(); };

// DynamickÃ¡ velikost ikon a volitelnÃ© barvy F/D
const ICON_BASE = 25; // ~1.8Ã— pÅ¯vodnÃ­ 18px
const TRI_BASE  = 25;
function _baseWidth(){ return (rink && rink.width) ? rink.width : 1400; }
function _displayWidth(){ try { return Math.max(1, canvas.getBoundingClientRect().width); } catch(_) { return canvas.width || 1; } }
function iconR(){ return Math.max(10, Math.round(ICON_BASE * (_displayWidth() / _baseWidth()))); }
function triR(){ return Math.max(10, Math.round(TRI_BASE  * (_displayWidth() / _baseWidth()))); }
let colorF = (localStorage.getItem('drillColorF') || '#0000ff');
let colorD = (localStorage.getItem('drillColorD') || '#ff0000');
try {
  const elF = document.getElementById('colorF');
  const elD = document.getElementById('colorD');
  if(elF){ elF.value = colorF; elF.addEventListener('input', e=>{ colorF = e.target.value || '#0000ff'; localStorage.setItem('drillColorF', colorF); }); }
  if(elD){ elD.value = colorD; elD.addEventListener('input', e=>{ colorD = e.target.value || '#ff0000'; localStorage.setItem('drillColorD', colorD); }); }
} catch(_) {}

const sizeInput = document.getElementById("canvasSize");
sizeInput.addEventListener("input", e => {
  manualSize = true;
  const w = parseInt(e.target.value, 10);
  // U slideru mÄ›nÃ­me jen vizuÃ¡lnÃ­ (CSS) Å¡Ã­Å™ku canvasu,
  // nikoli jeho internÃ­ souÅ™adnicovÃ½ systÃ©m ani data.
  canvas.style.width = w + 'px';
  // PÅ™ekresli, aby se pÅ™epoÄÃ­tala velikost ikon dle zobrazenÃ© Å¡Ã­Å™ky
  try { redrawAll(); } catch(_) {}
});

// Auto-resize na zmÄ›nu okna â€“ pokud uÅ¾ivatel ruÄnÄ› neupravil velikost a nic nenÃ­ nakresleno
let resizeTimer;
window.addEventListener('resize', function(){
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(function(){
    if(!manualSize){ resizeCanvas(containerWidth()); }
  }, 150);
});
 
  // OvlÃ¡dÃ¡nÃ­ synchronizaÄnÃ­ skupiny
  document.addEventListener('DOMContentLoaded', ()=>{
  // Mobile toolbar show/hide toggle with persistence
  try {
    var tbar = document.getElementById('toolbar');
    var btnT = document.getElementById('btnToggleToolbarMobile');
    var btnTD = document.getElementById('btnToggleToolbarDesktop');
    var fabT = document.getElementById('fabToggleToolbar');
    var pref = localStorage.getItem('drillToolbarVisible');
    var visible = (pref === null) ? true : (pref === '1');
    function applyVis(){
      if(tbar){ tbar.classList.toggle('toolbar--hidden', !visible); }
      if(btnT){ btnT.textContent = visible ? 'SkrÃ½t nÃ¡stroje' : 'Zobrazit nÃ¡stroje'; }
      if(btnTD){ btnTD.textContent = visible ? 'SkrÃ½t nÃ¡stroje' : 'Zobrazit nÃ¡stroje'; }
      if(fabT){ fabT.setAttribute('aria-label', visible ? 'SkrÃ½t nÃ¡stroje' : 'Zobrazit nÃ¡stroje'); }
    }
    applyVis();
    function toggleToolbar(){ visible = !visible; localStorage.setItem('drillToolbarVisible', visible ? '1' : '0'); applyVis(); }
    if(btnT){ btnT.addEventListener('click', toggleToolbar); }
    if(btnTD){ btnTD.addEventListener('click', toggleToolbar); }
    if(fabT){ fabT.addEventListener('click', toggleToolbar); }
  } catch(_){ }

  // KompaktnÃ­ reÅ¾im toolbaru (persist pÅ™es localStorage)
  try {
    const toolbarEl = document.getElementById('toolbar');
    const compactChk = document.getElementById('compactToggle');
    const stored = localStorage.getItem('drillToolbarCompact') === '1';
    if(stored){ toolbarEl?.classList.add('toolbar--compact'); if(compactChk) compactChk.checked = true; }
    if(compactChk){
      compactChk.addEventListener('change', function(){
        if(compactChk.checked){ toolbarEl?.classList.add('toolbar--compact'); localStorage.setItem('drillToolbarCompact','1'); }
        else { toolbarEl?.classList.remove('toolbar--compact'); localStorage.removeItem('drillToolbarCompact'); }
      });
    }
  } catch(_) {}

  // AktivnÃ­ nÃ¡stroj: oznaÄenÃ­ v toolbaru + pÅ™epÃ­nÃ¡nÃ­
  try {
    const toolbarEl = document.getElementById('toolbar');
    function markActive(tool){
      const btns = toolbarEl ? toolbarEl.querySelectorAll('.btn-tool') : [];
      btns.forEach(b => b.classList.remove('is-active'));
      const active = toolbarEl ? toolbarEl.querySelector(`.btn-tool[data-tool="${tool}"]`) : null;
      if(active) active.classList.add('is-active');
    }
    const btns = toolbarEl ? toolbarEl.querySelectorAll('.btn-tool') : [];
    btns.forEach(btn => {
      if(btn.id === 'btnToolGoal') return; // handled separately to show rotation picker
      btn.addEventListener('click', () => {
        const t = btn.getAttribute('data-tool');
        if(t){ currentTool = t; markActive(t); }
      });
    });
    // init default
    markActive(currentTool || 'straight');
  } catch(_) {}

  // Rotation picker for goal tool
  try {
    const btnGoal = document.getElementById('btnToolGoal');
    const picker = document.getElementById('goalRotationPicker');
    if(btnGoal && picker){
      btnGoal.addEventListener('click', (e)=>{
        currentTool = 'goal';
        // show picker inline next to buttons in the same group
        picker.style.display = (picker.style.display === 'none' || picker.style.display === '') ? 'flex' : 'none';
        // mark active in toolbar highlighter if present
        try { const tb = document.getElementById('toolbar'); tb?.querySelectorAll('.btn-tool').forEach(b=>b.classList.remove('is-active')); btnGoal.classList.add('is-active'); } catch(_){ }
        e.stopPropagation();
      });
      // Drag from main goal button uses currentGoalRotation
      btnGoal.addEventListener('dragstart', (ev) => {
        try {
          const rot = currentGoalRotation || 0;
          ev.dataTransfer?.setData('text/plain', `goal:${rot}`);
          ev.dataTransfer?.setData('application/x-goal', String(rot));
          if(ev.dataTransfer) ev.dataTransfer.effectAllowed = 'copy';
        } catch(_){ }
      });
      // Click-to-select rotation
      picker.querySelectorAll('button.btn-tool').forEach(b => {
        b.addEventListener('click', () => {
          const rot = parseInt(b.getAttribute('data-rot')||'0',10) || 0;
          currentGoalRotation = ((rot % 360) + 360) % 360;
          // ensure tool remains active as 'goal'
          currentTool = 'goal';
          try { const tb = document.getElementById('toolbar'); tb?.querySelectorAll('.btn-tool').forEach(x=>x.classList.remove('is-active')); btnGoal.classList.add('is-active'); } catch(_){ }
          // hide picker after select
          picker.style.display = 'none';
        });
      });
      // Drag-and-drop support: drag thumbnail from picker onto canvas
      picker.querySelectorAll('img').forEach(img => {
        img.addEventListener('dragstart', (ev) => {
          try {
            const b = img.closest('button.btn-tool');
            const rot = parseInt(b?.getAttribute('data-rot')||'0',10) || 0;
            ev.dataTransfer?.setData('text/plain', `goal:${rot}`);
            ev.dataTransfer?.setData('application/x-goal', String(rot));
            if(ev.dataTransfer) ev.dataTransfer.effectAllowed = 'copy';
            currentTool = 'goal';
          } catch(_){ }
        });
      });
      // clicking elsewhere hides the picker
      document.addEventListener('click', (ev)=>{
        try {
          if(!picker.contains(ev.target) && ev.target !== btnGoal){ picker.style.display = 'none'; }
        } catch(_){ }
      });
    }
  } catch(_){}

  const startChk = document.getElementById('syncStart');
  const endChk = document.getElementById('syncEnd');
  const lblStart = document.getElementById('lblSyncStart');
  const lblEnd = document.getElementById('lblSyncEnd');
  const pill = document.getElementById('syncStatus');
  // dropped passSyncNext

  function updateSyncIndicators(){
    if(syncActive){
      lblStart.classList.add('active');
      lblEnd.classList.remove('active');
      lblStart.classList.remove('off');
      lblEnd.classList.add('off');
      pill.classList.remove('off');
      pill.classList.add('on');
      pill.textContent = 'SouÄasnÄ›: zapnuto';
    } else {
      lblStart.classList.remove('active');
      lblEnd.classList.add('active');
      lblStart.classList.add('off');
      lblEnd.classList.remove('off');
      pill.classList.remove('on');
      pill.classList.add('off');
      pill.textContent = 'SouÄasnÄ›: vypnuto';
    }
    // no passSyncNext
  }
  updateSyncIndicators();
  if(startChk){
    startChk.addEventListener('change', ()=>{
      if(startChk.checked){
        if(!syncActive){ syncCounter += 1; syncActive = true; }
        startChk.checked = false; // funguje jako tlaÄÃ­tko
        updateSyncIndicators();
      }
    });
  }
  if(endChk){
    endChk.addEventListener('change', ()=>{
      if(endChk.checked){ syncActive = false; endChk.checked = false; updateSyncIndicators(); }
    });
  }
  // no passSyncNext listener
  // inicializuj prÃ¡zdnÃ½ log
  try { renderSeqLog(); } catch(_) {}
});


function resizeCanvas(width) {
    const oldW = canvas.width || width;
    const oldH = canvas.height || ((width / rink.width) * rink.height);
    canvas.width = width;
    canvas.height = (canvas.width / rink.width) * rink.height;
    const sx = (oldW > 0) ? (canvas.width / oldW) : 1;
    const sy = (oldH > 0) ? (canvas.height / oldH) : 1;
    if (drawData && drawData.length) {
        scaleDrawData(sx, sy);
        redrawAll();
    } else {
        ctx.drawImage(rink, 0, 0, canvas.width, canvas.height);
    }
}

function setTool(t) { currentTool = t; }
function clearCanvas() { ctx.clearRect(0,0,canvas.width,canvas.height); ctx.drawImage(rink,0,0,canvas.width,canvas.height); drawData = []; saveState(); renderSeqLog(); }
function saveState() {
    history.push(canvas.toDataURL());
    dataHistory.push(JSON.stringify(drawData));
    if(history.length>30){ history.shift(); dataHistory.shift(); }
}
function undo() {
    if(history.length>1){
        history.pop();
        dataHistory.pop();
        const prevData = dataHistory.at(-1);
        try { drawData = JSON.parse(prevData || '[]'); } catch(_) { drawData = []; }
        let img=new Image();
        img.src=history.at(-1);
        img.onload=()=>{ctx.clearRect(0,0,canvas.width,canvas.height);ctx.drawImage(img,0,0,canvas.width,canvas.height);};
        renderSeqLog();
    }
}
// --- Minimal-size snapshot helper: overlay-only, downscaled WebP ---
function renderOverlayToContext(targetCtx){
  const prev = ctx;
  ctx = targetCtx;
  try {
    if(!drawData) return;
    for(const it of drawData){
      try{
        if(it.tool === 'player_move_puck' && it.path){
          // Wavy puck move
          drawWavyLine(it.path, 10, 40);
          const n = it.path.length;
          if(n>=2){ const [sx,sy]=it.path[n-2]; const [ex,ey]=it.path[n-1]; drawArrowHead(sx,sy,ex,ey,'black'); }
        } else if(it.tool === 'player_move' && it.path){
          const n = it.path.length;
          if(it.style === 'zigzag'){
            drawZigZagLine(it.path,10,40);
            if(n>=2){ const [sx,sy]=it.path[n-2]; const [ex,ey]=it.path[n-1]; drawArrowHead(sx,sy,ex,ey,'black'); }
          } else if(it.style === 'curve' || n > 2){
            drawCatmullRomLine(it.path);
            if(n>=2){ const [sx,sy]=it.path[n-2]; const [ex,ey]=it.path[n-1]; drawArrowHead(sx,sy,ex,ey,'black'); }
          } else if(n === 2){
            ctx.beginPath(); ctx.moveTo(it.path[0][0], it.path[0][1]); ctx.lineTo(it.path[1][0], it.path[1][1]); ctx.stroke();
            drawArrowHead(it.path[0][0], it.path[0][1], it.path[1][0], it.path[1][1], 'black');
          }
        } else if(it.tool === 'puck' && it.path){
          // pass/shot
          if(it.style === 'pass' || it.pass){ ctx.setLineDash([5,5]); }
          if(it.style === 'shot' || it.shot){ ctx.beginPath(); ctx.arc(it.path[0][0], it.path[0][1], 6, 0, 2*Math.PI); ctx.fill(); }
          ctx.beginPath(); ctx.moveTo(it.path[0][0], it.path[0][1]); ctx.lineTo(it.path[1][0], it.path[1][1]); ctx.stroke(); ctx.setLineDash([]);
          drawArrowHead(it.path[0][0], it.path[0][1], it.path[1][0], it.path[1][1], 'black');
        } else if(it.tool === 'puck_static' && typeof it.x==='number'){
          ctx.beginPath(); ctx.arc(it.x, it.y, 6, 0, 2*Math.PI); ctx.fill();
        } else if(it.tool === 'pucks_cluster' && typeof it.x==='number'){
          ctx.fillStyle = 'black';
          for(let i=-1;i<=1;i++){ for(let j=-1;j<=1;j++){ if(i||j){ ctx.beginPath(); ctx.arc(it.x+i*12, it.y+j*12, 5, 0, 2*Math.PI); ctx.fill(); } } }
          ctx.beginPath(); ctx.arc(it.x, it.y, 6, 0, 2*Math.PI); ctx.fill();
        } else if(it.tool === 'goal' && typeof it.x==='number'){
          drawGoalImage(it.x, it.y, parseInt(it.rot||0,10)||0);
        } else if(it.tool === 'cone' && typeof it.x==='number'){
          ctx.fillStyle = 'orange'; ctx.beginPath(); ctx.moveTo(it.x, it.y); ctx.lineTo(it.x-10, it.y+20); ctx.lineTo(it.x+10, it.y+20); ctx.closePath(); ctx.fill();
        } else if(it.tool === 'triangle' && typeof it.x==='number'){
          ctx.fillStyle = 'purple'; ctx.beginPath(); ctx.moveTo(it.x, it.y-15); ctx.lineTo(it.x-15, it.y+15); ctx.lineTo(it.x+15, it.y+15); ctx.closePath(); ctx.fill();
        } else if(it.tool === 'player_icon' && typeof it.x==='number'){
          const label = it.role || 'F';
          const col = it.color || (label==='D' ? (typeof colorD!=='undefined'?colorD:'#ff0000') : (label==='F' ? (typeof colorF!=='undefined'?colorF:'#0000ff') : 'black'));
          if(label === 'D'){
            const R = triR();
            ctx.fillStyle=col; ctx.beginPath(); ctx.moveTo(it.x, it.y-R); ctx.lineTo(it.x-R, it.y+R); ctx.lineTo(it.x+R, it.y+R); ctx.closePath(); ctx.fill();
          } else {
            const R = iconR();
            ctx.beginPath(); ctx.arc(it.x, it.y, R, 0, 2*Math.PI); ctx.fillStyle=col; ctx.fill();
          }
        }
      }catch(_){ /* ignore item draw errors */ }
    }
  } finally {
    ctx = prev;
  }
}

function makeOverlayPreviewDataURL(maxWidth){
  const MAX_W = Math.max(600, maxWidth || 900);
  const s = Math.min(1, MAX_W / Math.max(1, canvas.width));
  const w = Math.round(canvas.width * s);
  const h = Math.round(canvas.height * s);
  const off = document.createElement('canvas');
  off.width = w; off.height = h;
  const oc = off.getContext('2d');
  // Draw rink background scaled to snapshot size to keep previews familiar
  try { oc.drawImage(rink, 0, 0, w, h); } catch(_) {}
  oc.save();
  oc.scale(s, s);
  renderOverlayToContext(oc);
  oc.restore();
  // Prefer WebP; browsers that don't support it will typically fallback to PNG
  let url = off.toDataURL('image/webp', 0.8);
  if(!/^data:image\/webp[,;]/.test(url)){
    // Fallback to JPEG with decent quality
    url = off.toDataURL('image/jpeg', 0.8);
  }
  return url;
}

function _dataWithMeta(){
  const meta = { tool: 'meta', canvas_w: canvas.width || 0, canvas_h: canvas.height || 0 };
  const arr = Array.isArray(drawData) ? drawData.slice() : [];
  if(arr.length && arr[0] && arr[0].tool === 'meta'){
    const copy = arr.slice();
    copy[0] = { ...(copy[0]||{}), canvas_w: meta.canvas_w, canvas_h: meta.canvas_h };
    return copy;
  }
  return [meta, ...arr];
}

function saveImage(){
  document.getElementById("image_data").value = makeOverlayPreviewDataURL(900);
  document.getElementById("path_data").value = JSON.stringify(_dataWithMeta());
} 

function getCanvasCoords(e){
  const rect = canvas.getBoundingClientRect();
  const scaleX = (canvas.width  || rect.width) / rect.width;
  const scaleY = (canvas.height || rect.height) / rect.height;
  if (e.touches && e.touches[0]) {
    const t = e.touches[0];
    return [ (t.clientX - rect.left) * scaleX, (t.clientY - rect.top) * scaleY ];
  }
  if (e.changedTouches && e.changedTouches[0]) {
    const t = e.changedTouches[0];
    return [ (t.clientX - rect.left) * scaleX, (t.clientY - rect.top) * scaleY ];
  }
  // Mouse events: use clientX/clientY (offsetX breaks with CSS scaling)
  const cx = e.clientX ?? 0; const cy = e.clientY ?? 0;
  return [ (cx - rect.left) * scaleX, (cy - rect.top) * scaleY ];
}

// Mouse
canvas.addEventListener("mousedown",e=>{
    drawing=true;[startX,startY]=getCanvasCoords(e);pathPoints=[[startX,startY]];ctx.beginPath();ctx.moveTo(startX,startY);
    // Instant-place tools (no drag): goal
    if(currentTool === 'goal'){
        handleDrawingEnd(startX, startY);
        saveState();
        drawing = false; _placedImmediate = true;
    }
});
canvas.addEventListener("mousemove",e=>{
    if(!drawing) return;
    let [x,y] = getCanvasCoords(e);
    if(["wave","zigzag"].includes(currentTool)){
        // PÅ¯vodnÃ­ chovÃ¡nÃ­: pÅ™i kreslenÃ­ vykresluj jednoduchou linku
        pathPoints.push([x,y]);
        ctx.lineTo(x,y);
        ctx.strokeStyle = "black";
        ctx.lineWidth = 2;
        ctx.stroke();
    } else if(currentTool === "curve"){
        // Free draw â€“ sbÃ­rej body, vyhladÃ­me aÅ¾ na konci
        pathPoints.push([x,y]);
    }
});
canvas.addEventListener("mouseup",e=>{ if(_placedImmediate){ _placedImmediate=false; return; } if(!drawing)return; drawing=false; let[x,y]=getCanvasCoords(e); handleDrawingEnd(x,y); saveState(); });

// Drag & drop (goal from toolbar)
try {
  canvas.addEventListener('dragover', (e) => { e.preventDefault(); try{ e.dataTransfer.dropEffect = 'copy'; }catch(_){} });
  canvas.addEventListener('drop', (e) => {
    e.preventDefault();
    try {
      let data = e.dataTransfer?.getData('application/x-goal') || e.dataTransfer?.getData('text/plain') || '';
      let rot = 0;
      if(typeof data === 'string' && data){
        if(/^\d+$/.test(data.trim())) rot = parseInt(data.trim(),10) || 0;
        else if(data.startsWith('goal:')) rot = parseInt(data.slice(5).trim(),10) || 0;
      }
      const [x,y] = getCanvasCoords(e);
      currentTool = 'goal';
      currentGoalRotation = ((rot % 360) + 360) % 360;
      drawGoalImage(x,y,currentGoalRotation);
      drawData.push({tool:'goal', x, y, rot: currentGoalRotation});
      saveState();
      try { document.getElementById('goalRotationPicker')?.style && (document.getElementById('goalRotationPicker').style.display = 'none'); } catch(_){}
      renderSeqLog();
    } catch(_){}
  });
} catch(_){}

// Touch
canvas.addEventListener("touchstart",e=>{e.preventDefault();drawing=true;[startX,startY]=getCanvasCoords(e);pathPoints=[[startX,startY]];ctx.beginPath();ctx.moveTo(startX,startY);
  if(currentTool === 'goal'){
    handleDrawingEnd(startX, startY);
    saveState();
    drawing = false; _placedImmediate = true;
  }
}, {passive:false});
canvas.addEventListener("touchmove", e => {
    e.preventDefault();
    if(!drawing) return;
    let [x,y] = getCanvasCoords(e);
    // Na mobilu vÅ¾dy udrÅ¾uj poslednÃ­ souÅ™adnici, aby touchend znal cÃ­l
    pathPoints.push([x,y]);
    if(["wave","zigzag"].includes(currentTool)){
        ctx.lineTo(x,y);
        ctx.strokeStyle = "black";
        ctx.lineWidth = 2;
        ctx.stroke();
    }
}, {passive:false});
canvas.addEventListener("touchend", e => {
    e.preventDefault();
    if(_placedImmediate){ _placedImmediate=false; return; }
    if(!drawing) return;
    drawing = false;
    let x = startX, y = startY;
    try {
      const coords = getCanvasCoords(e);
      if (coords && coords.length === 2) { x = coords[0]; y = coords[1]; }
      else if (pathPoints.length) { [x,y] = pathPoints.at(-1); }
    } catch(_) { if (pathPoints.length){ [x,y] = pathPoints.at(-1); } }
    handleDrawingEnd(x,y);
    saveState();
}, {passive:false});

// PÅ™epoÄet dat pÅ™i zmÄ›nÄ› velikosti
function scaleDrawData(sx, sy){
  if(!drawData || !Array.isArray(drawData)) return;
  for(const it of drawData){
    if(it.path && Array.isArray(it.path)){
      for(let i=0;i<it.path.length;i++){
        it.path[i] = [ it.path[i][0] * sx, it.path[i][1] * sy ];
      }
    }
    if(typeof it.x === 'number' && typeof it.y === 'number'){
      it.x = it.x * sx; it.y = it.y * sy;
    }
  }
}

function redrawAll(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(rink,0,0,canvas.width,canvas.height);
  if(!drawData) return;
  for(const it of drawData){
    try{
      if(it.tool === 'player_move_puck' && it.path){
        // Wavy puck move
        drawWavyLine(it.path, 10, 40);
        const n = it.path.length;
        if(n>=2){ const [sx,sy]=it.path[n-2]; const [ex,ey]=it.path[n-1]; drawArrowHead(sx,sy,ex,ey,'black'); }
      } else if(it.tool === 'player_move' && it.path){
        const n = it.path.length;
        if(it.style === 'zigzag'){
          drawZigZagLine(it.path,10,40);
          if(n>=2){ const [sx,sy]=it.path[n-2]; const [ex,ey]=it.path[n-1]; drawArrowHead(sx,sy,ex,ey,'black'); }
        } else if(it.style === 'curve' || n > 2){
          drawCatmullRomLine(it.path);
          if(n>=2){ const [sx,sy]=it.path[n-2]; const [ex,ey]=it.path[n-1]; drawArrowHead(sx,sy,ex,ey,'black'); }
        } else if(n === 2){
          ctx.beginPath(); ctx.moveTo(it.path[0][0], it.path[0][1]); ctx.lineTo(it.path[1][0], it.path[1][1]); ctx.stroke();
          drawArrowHead(it.path[0][0], it.path[0][1], it.path[1][0], it.path[1][1], 'black');
        }
      } else if(it.tool === 'puck' && it.path){
        // pass/shot
        if(it.style === 'pass' || it.pass){ ctx.setLineDash([5,5]); }
        // draw small origin dot for shot
        if(it.style === 'shot' || it.shot){ ctx.beginPath(); ctx.arc(it.path[0][0], it.path[0][1], 6, 0, 2*Math.PI); ctx.fill(); }
        ctx.beginPath(); ctx.moveTo(it.path[0][0], it.path[0][1]); ctx.lineTo(it.path[1][0], it.path[1][1]); ctx.stroke(); ctx.setLineDash([]);
        drawArrowHead(it.path[0][0], it.path[0][1], it.path[1][0], it.path[1][1], 'black');
      } else if(it.tool === 'puck_static' && typeof it.x==='number'){
        ctx.beginPath(); ctx.arc(it.x, it.y, 6, 0, 2*Math.PI); ctx.fill();
      } else if(it.tool === 'pucks_cluster' && typeof it.x==='number'){
        ctx.fillStyle = 'black';
        for(let i=-1;i<=1;i++){ for(let j=-1;j<=1;j++){ if(i||j){ ctx.beginPath(); ctx.arc(it.x+i*12, it.y+j*12, 5, 0, 2*Math.PI); ctx.fill(); } } }
        ctx.beginPath(); ctx.arc(it.x, it.y, 6, 0, 2*Math.PI); ctx.fill();
      } else if(it.tool === 'goal' && typeof it.x==='number'){
        drawGoalImage(it.x, it.y, parseInt(it.rot||0,10)||0);
      } else if(it.tool === 'cone' && typeof it.x==='number'){
        ctx.fillStyle = 'orange'; ctx.beginPath(); ctx.moveTo(it.x, it.y); ctx.lineTo(it.x-10, it.y+20); ctx.lineTo(it.x+10, it.y+20); ctx.closePath(); ctx.fill();
      } else if(it.tool === 'triangle' && typeof it.x==='number'){
        ctx.fillStyle = 'purple'; ctx.beginPath(); ctx.moveTo(it.x, it.y-15); ctx.lineTo(it.x-15, it.y+15); ctx.lineTo(it.x+15, it.y+15); ctx.closePath(); ctx.fill();
      } else if(it.tool === 'player_icon' && typeof it.x==='number'){
        const label = it.role || 'F';
        const col = it.color || (label==='D' ? (typeof colorD!=='undefined'?colorD:'#ff0000') : (label==='F' ? (typeof colorF!=='undefined'?colorF:'#0000ff') : 'black'));
        if(label === 'D'){
          const R = triR();
          ctx.fillStyle=col; ctx.beginPath(); ctx.moveTo(it.x, it.y-R); ctx.lineTo(it.x-R, it.y+R); ctx.lineTo(it.x+R, it.y+R); ctx.closePath(); ctx.fill();
        } else {
          const R = iconR();
          ctx.beginPath(); ctx.arc(it.x, it.y, R, 0, 2*Math.PI); ctx.fillStyle=col; ctx.fill();
        }
      }
    }catch(_){ /* ignore item draw errors */ }
  }
}

// -------------------------------
// Drawing logic + uklÃ¡dÃ¡nÃ­ do drawData
// -------------------------------
function handleDrawingEnd(x,y){
    const tol = Math.max(2, canvas.width * 0.003);
    if(currentTool==="straight"){ ctx.beginPath();ctx.moveTo(startX,startY);ctx.lineTo(x,y);ctx.strokeStyle="black";ctx.lineWidth=2;ctx.stroke();drawArrowHead(startX,startY,x,y,"black"); const sg = syncActive ? syncCounter : null; const obj = {tool:"player_move",style:"straight",path:[[startX,startY],[x,y]]}; if(sg) obj.sync_group = sg; drawData.push(obj); }
    else if(currentTool==="curve"&&pathPoints.length>1){
        const sp = processCurvePath(pathPoints);
        drawCatmullRomLine(sp);
        const [ax,ay] = sp[sp.length-2] || sp[0];
        const [bx,by] = sp[sp.length-1];
        drawArrowHead(ax,ay,bx,by,"black");
        const syncGroup = syncActive ? syncCounter : null;
        const obj = {tool:"player_move",style:"curve",path:sp};
        if(syncGroup) obj.sync_group = syncGroup;
        drawData.push(obj);
    }
    else if(currentTool==="wave"&&pathPoints.length>1){
        // PÅ¯vodnÃ­ chovÃ¡nÃ­: pouÅ¾ij pÅ¯vodnÃ­ body bez vyhlazenÃ­
        drawWavyLine(pathPoints,10,40);
        let[sx,sy]=pathPoints.at(-2);
        drawArrowHead(sx,sy,x,y,"black");
        const syncGroup = syncActive ? syncCounter : null;
        const obj = {tool:"player_move_puck",style:"wavy",path:pathPoints};
        if(syncGroup) obj.sync_group = syncGroup;
        drawData.push(obj);
    }
    else if(currentTool==="zigzag"&&pathPoints.length>1){
        // PÅ¯vodnÃ­ chovÃ¡nÃ­: pouÅ¾ij pÅ¯vodnÃ­ body bez vyhlazenÃ­
        drawZigZagLine(pathPoints,10,40);
        let[sx,sy]=pathPoints.at(-2);
        drawArrowHead(sx,sy,x,y,"black");
        const syncGroup = syncActive ? syncCounter : null;
        const obj = {tool:"player_move",style:"zigzag",path:pathPoints};
        if(syncGroup) obj.sync_group = syncGroup;
        drawData.push(obj);
    }
    else if(currentTool==="double"){ctx.beginPath();ctx.arc(startX,startY,6,0,2*Math.PI);ctx.fill();ctx.beginPath();ctx.moveTo(startX,startY);ctx.lineTo(x,y);ctx.stroke();drawArrowHead(startX,startY,x,y,"black");drawData.push({tool:"puck",style:"shot",shot:true,sync_next:0,path:[[startX,startY],[x,y]]});}
    else if(currentTool==="dotted"){ctx.setLineDash([5,5]);ctx.beginPath();ctx.moveTo(startX,startY);ctx.lineTo(x,y);ctx.stroke();ctx.setLineDash([]);drawArrowHead(startX,startY,x,y,"black");drawData.push({tool:"puck",style:"pass",pass:true,sync_next:0,path:[[startX,startY],[x,y]]});}
    else if(currentTool==="puck"){ctx.beginPath();ctx.arc(x,y,6,0,2*Math.PI);ctx.fill();drawData.push({tool:"puck_static",x,y});}
    else if(currentTool==="pucks"){ctx.fillStyle="black";for(let i=-1;i<=1;i++){for(let j=-1;j<=1;j++){if(i||j){ctx.beginPath();ctx.arc(x+i*12,y+j*12,5,0,2*Math.PI);ctx.fill();}}}ctx.beginPath();ctx.arc(x,y,6,0,2*Math.PI);ctx.fill();drawData.push({tool:"pucks_cluster",x,y});}
    else if(currentTool==="cone"){ctx.fillStyle="orange";ctx.beginPath();ctx.moveTo(x,y);ctx.lineTo(x-10,y+20);ctx.lineTo(x+10,y+20);ctx.closePath();ctx.fill();drawData.push({tool:"cone",x,y});}
    else if(currentTool==="goal"){ drawGoalImage(x,y,currentGoalRotation||0); drawData.push({tool:"goal", x, y, rot: (currentGoalRotation||0)}); }
    else if(currentTool.startsWith("circle")){
        let label=(currentTool==="circleF")?"F":(currentTool==="circleD")?"D":"G";
        if(currentTool==="circleD"){
            // ObrÃ¡nce jako trojÃºhelnÃ­k â€“ barva a velikost dle nastavenÃ­
            const R = triR();
            ctx.fillStyle=(typeof colorD!=='undefined'?colorD:"red");
            ctx.beginPath();
            ctx.moveTo(x, y-R);
            ctx.lineTo(x-R, y+R);
            ctx.lineTo(x+R, y+R);
            ctx.closePath();
            ctx.fill();
        } else {
            // ÃštoÄnÃ­k/BrankÃ¡Å™ jako koleÄko â€“ barva a velikost dle nastavenÃ­
            const R = iconR();
            ctx.beginPath();ctx.arc(x,y,R,0,2*Math.PI);
            ctx.fillStyle=(currentTool==="circleF")?(typeof colorF!=='undefined'?colorF:"blue"):"black";
            ctx.fill();
        }
        drawData.push({tool:"player_icon",role:label,x,y,color: (label==="D" ? (typeof colorD!=='undefined'?colorD:'#ff0000') : (label==="F" ? (typeof colorF!=='undefined'?colorF:'#0000ff') : 'black'))});
    }
    else if(currentTool==="triangle"){ctx.fillStyle="purple";ctx.beginPath();ctx.moveTo(x,y-15);ctx.lineTo(x-15,y+15);ctx.lineTo(x+15,y+15);ctx.closePath();ctx.fill();drawData.push({tool:"triangle",x,y});}
    renderSeqLog();
}

// Utility kreslenÃ­
function goalSize(){ return Math.round(iconR() * 2 * 1.25); } // troÅ¡ku vÄ›tÅ¡Ã­ neÅ¾ hrÃ¡ÄskÃ¡ ikona
function drawGoalImage(x,y,deg){
    try{
        const size = goalSize();
        const r = (deg||0) * Math.PI/180;
        ctx.save();
        ctx.translate(x,y);
        ctx.rotate(r);
        ctx.drawImage(goalImg, -size/2, -size/2, size, size);
        ctx.restore();
    }catch(_){/* ignore */}
}
function drawArrowHead(x1,y1,x2,y2,color){let a=Math.atan2(y2-y1,x2-x1);ctx.beginPath();ctx.moveTo(x2,y2);ctx.lineTo(x2-10*Math.cos(a-Math.PI/6),y2-10*Math.sin(a-Math.PI/6));ctx.lineTo(x2-10*Math.cos(a+Math.PI/6),y2-10*Math.sin(a+Math.PI/6));ctx.closePath();ctx.fillStyle=color;ctx.fill();}
function simplifyPath(points,tol){
    if(points.length<=2) return points.slice();
    const pts = points.map(p=>({x:p[0],y:p[1]}));
    function distToSeg(p,a,b){
        const A=p.x-a.x,B=p.y-a.y,C=b.x-a.x,D=b.y-a.y;
        const dot=A*C+B*D,len=C*C+D*D; const t=Math.max(0,Math.min(1,len?dot/len:0));
        const xx=a.x+t*C, yy=a.y+t*D; const dx=p.x-xx, dy=p.y-yy; return Math.hypot(dx,dy);
    }
    function rdp(arr, s, e, tol, out){
        let maxD=0, idx=-1;
        for(let i=s+1;i<e;i++){ const d=distToSeg(arr[i], arr[s], arr[e]); if(d>maxD){maxD=d;idx=i;} }
        if(maxD>tol && idx>0){ rdp(arr,s,idx,tol,out); rdp(arr,idx,e,tol,out); }
        else { out.push(arr[s]); }
    }
    const out=[]; rdp(pts,0,pts.length-1,tol,out); out.push(pts[pts.length-1]);
    return out.map(p=>[p.x,p.y]);
}
function processCurvePath(points){
    // 1) lehkÃ© zÅ™edÄ›nÃ­/normalizace krokem 3px pro menÅ¡Ã­ kostrbatost
    const step = 3; // px
    let res = resamplePath(points, step);
    // 2) jemnÃ½ klouzavÃ½ prÅ¯mÄ›r (okno 1) â€“ drÅ¾Ã­ tvar, potlaÄÃ­ Å¡um
    if(res.length > 2){
        const out=[]; const w=1;
        for(let i=0;i<res.length;i++){
            let sx=0, sy=0, c=0;
            for(let k=-w;k<=w;k++){
                const j=Math.min(res.length-1, Math.max(0,i+k)); sx+=res[j][0]; sy+=res[j][1]; c++;
            }
            out.push([sx/c, sy/c]);
        }
        res = out;
    }
    return res;
}
function drawCatmullRomLine(points){
    if(points.length < 2){ return; }
    ctx.beginPath();
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 2;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    // Duplicate endpoints for boundary conditions
    const pts = points.slice();
    const p0 = points[0];
    const pn = points[points.length-1];
    pts.unshift(p0);
    pts.push(pn);
    ctx.moveTo(points[0][0], points[0][1]);
    for(let i=1;i<pts.length-2;i++){
        const p0 = pts[i-1], p1 = pts[i], p2 = pts[i+1], p3 = pts[i+2];
        // Catmull-Rom to Bezier (uniform, s=1/6*1)
        const c1x = p1[0] + (p2[0]-p0[0]) / 6;
        const c1y = p1[1] + (p2[1]-p0[1]) / 6;
        const c2x = p2[0] - (p3[0]-p1[0]) / 6;
        const c2y = p2[1] - (p3[1]-p1[1]) / 6;
        ctx.bezierCurveTo(c1x, c1y, c2x, c2y, p2[0], p2[1]);
    }
    ctx.stroke();
}
function drawWavyLine(points,a,w){let r=resamplePath(points,5);ctx.beginPath();for(let i=1;i<r.length;i++){let[x1,y1]=r[i-1];let[x2,y2]=r[i];let ang=Math.atan2(y2-y1,x2-x1);let nx=-Math.sin(ang),ny=Math.cos(ang);let off=Math.sin((i*5)/w*2*Math.PI)*a;ctx.lineTo(x2+nx*off,y2+ny*off);}ctx.stroke();}
function drawZigZagLine(points,a,w){let r=resamplePath(points,w);ctx.beginPath();for(let i=0;i<r.length;i++){let[x,y]=r[i];if(i===0)ctx.moveTo(x,y);else{let[px,py]=r[i-1];let ang=Math.atan2(y-py,x-px);let nx=-Math.sin(ang),ny=Math.cos(ang);let off=(i%2===0?a:-a);ctx.lineTo(x+nx*off,y+ny*off);}}ctx.stroke();}
function resamplePath(points,step){let r=[points[0]],dist=0;for(let i=1;i<points.length;i++){let[x1,y1]=points[i-1];let[x2,y2]=points[i];let dx=x2-x1,dy=y2-y1;let len=Math.sqrt(dx*dx+dy*dy);let steps=Math.floor((dist+len)/step);for(let s=1;s<=steps;s++){let t=(s*step-dist)/len;if(t>=0&&t<=1)r.push([x1+dx*t,y1+dy*t]);}dist=(dist+len)%step;}return r;}

function saveImage() {
    document.getElementById("image_data").value = makeOverlayPreviewDataURL(900);
    document.getElementById("path_data").value = JSON.stringify(_dataWithMeta());  // âœ… uklÃ¡dÃ¡me animaci s meta canvas size
}

// ----- Log sekvencÃ­ (souÄasnÃ© skupiny) -----
function renderSeqLog(){
    let html = '';
    let seqNum = 0;
    let currentGroup = null; // {id, items:[]}
    function labelOf(it){
        if(it.tool === 'player_move_puck') return 'pohyb s pukem';
        if(it.tool === 'player_move') return 'pohyb bez puku';
        if(it.tool === 'puck') return it.shot ? 'stÅ™ela' : 'nahrÃ¡vka';
        return it.tool;
    }
    function flushGroup(){
        if(!currentGroup) return;
        seqNum += 1;
        const items = currentGroup.items.map(labelOf).join(', ');
        html += `<div>sekvence ${seqNum}: ${items}</div>`;
        currentGroup = null;
    }
    for(const it of drawData){
        const sg = parseInt(it.sync_group||0,10)||0;
        if(sg>0){
            if(!currentGroup || currentGroup.id !== sg){ flushGroup(); currentGroup = {id: sg, items: []}; }
            currentGroup.items.push(it);
        } else {
            flushGroup();
            seqNum += 1;
            html += `<div>sekvence ${seqNum}: ${labelOf(it)}</div>`;
        }
    }
    flushGroup();
    let logBox = document.getElementById('seqLog');
    if(!logBox){
        logBox = document.createElement('div');
        logBox.id = 'seqLog';
        logBox.style.marginTop = '10px';
        logBox.style.padding = '8px';
        logBox.style.border = '1px dashed #000';
        logBox.style.background = '#f8f8f8';
        logBox.style.color = '#000';
        canvas.parentElement.appendChild(logBox);
    }
    logBox.innerHTML = `<b>Log sekvencÃ­:</b><div style="margin-top:6px; font-size:14px;">${html || 'â€”'}</div>`;
}

</script>
{% endblock %}

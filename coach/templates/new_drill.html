{% extends "base.html" %}
{% block title %}Nové cvičení{% endblock %}

{% block content %}
<h1>Nové cvičení</h1>

<form id="newDrillForm" method="POST" action="{{ url_for('save_drill') }}">
    <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
    <p><b>Název:</b> <input type="text" name="name" required></p>
    <p><b>Kategorie:</b> <input type="text" name="category" required></p>
    <p><b>Popis:</b><br><textarea name="description" rows="3" style="width:100%;"></textarea></p>
    <p><b>Doba (min):</b> <input type="number" name="duration" min="1"></p>

    <!-- 🎚 Slider na velikost rink canvasu -->
    <p>
        Velikost plochy:
        <input type="range" id="canvasSize" min="600" max="2000" value="1400" step="50">
    </p>

    <!-- Toolbar + canvas -->
    <div class="draw-container">
        <div class="toolbar-toggle-desktop">
          <button type="button" id="btnToggleToolbarDesktop">Skrýt nástroje</button>
        </div>
        <div class="toolbar-toggle-mobile">
          <button type="button" id="btnToggleToolbarMobile">Skrýt nástroje</button>
        </div>
        <div class="toolbar toolbar--compact" id="toolbar">
            <style>
              .toolbar{ display:flex; flex-wrap:wrap; gap:10px; align-items:flex-start; background: var(--brand-primary, #d4c76f); padding:8px; border-radius:12px; }
              .toolbar .tool-group{ display:flex; align-items:center; gap:8px; flex-wrap:wrap; background:transparent; padding:6px 8px; border-radius:10px; }
              .toolbar .group-title{ font-weight:700; font-size:12px; opacity:.7; margin-right:6px; }
              .toolbar .btn-tool{ min-width:36px; height:36px; padding:4px 8px; border:1px solid var(--brand-secondary, #000); background:#fff; color: var(--brand-secondary, #000); border-radius:8px; cursor:pointer; display:inline-flex; align-items:center; justify-content:center; gap:6px; }
              .toolbar .btn-tool .ic{ font-size:20px; line-height:1; }
              .toolbar .btn-tool .lbl{ font-size:12px; }
              .toolbar .btn-tool:hover{ background: color-mix(in srgb, #fff 70%, var(--brand-primary, #d4c76f) 30%); }
              .toolbar--compact .group-title{ display:none; }
              .toolbar--compact .btn-tool{ width:36px; min-width:36px; padding:0; }
              .toolbar--compact .btn-tool .lbl{ display:none; }
              .toolbar .toggle-label{ padding:6px 8px; border-radius:6px; background: color-mix(in srgb, var(--brand-primary, #d4c76f) 25%, white); color: var(--brand-secondary, #000); cursor:pointer; font-size:14px; }
              .toolbar .toggle-label.active { background: #3bb273; color:#fff; }
              .toolbar .toggle-label.off { background: #c44747; color:#fff; }
              .toolbar .pill { display:inline-block; padding:4px 10px; border-radius:999px; font-size:13px; margin-top:6px; }
              .toolbar .pill.on { background: #3bb273; color:#fff; }
              .toolbar .pill.off { background: #c44747; color:#fff; }
            </style>
            <div class="tool-group">
              <span class="group-title">Zobrazení</span>
              <label class="toggle-label" style="display:flex; align-items:center; gap:6px;" title="Kompaktní režim toolbaru (ikony)">
                <input type="checkbox" id="compactToggle" checked> <span class="lbl">Kompaktní režim</span>
              </label>
            </div>
            <div class="tool-group">
              <span class="group-title">Pohyb</span>
              <button type="button" class="btn-tool" data-tool="straight" title="Pohyb bez puku"><span class="ic">→</span><span class="lbl">Pohyb bez puku (rovně)</span></button>
              <button type="button" class="btn-tool" data-tool="curve" title="Pohyb bez puku (volný)"><span class="ic">〰</span><span class="lbl">Pohyb bez puku</span></button>
              <button type="button" class="btn-tool" data-tool="wave" title="Pohyb s pukem"><span class="ic">≈</span><span class="lbl">Jízda s pukem</span></button>
              <button type="button" class="btn-tool" data-tool="zigzag" title="Jízda vzad"><span class="ic">↯</span><span class="lbl">Jízda vzad</span></button>
            </div>
            <div class="tool-group">
              <span class="group-title">Akce s pukem</span>
              <button type="button" class="btn-tool" data-tool="dotted" title="Nahrávka"><span class="ic">⋯→</span><span class="lbl">Nahrávka</span></button>
              <button type="button" class="btn-tool" data-tool="double" title="Střela"><span class="ic">●→</span><span class="lbl">Střela</span></button>
            </div>
            <div class="tool-group">
              <span class="group-title">Ikony/Objekty</span>
              <button type="button" class="btn-tool" data-tool="circleF" title="Útočník (F)"><span class="ic">🔵</span><span class="lbl">F</span></button>
              <button type="button" class="btn-tool" data-tool="circleD" title="Obránce (D)"><span class="ic">🔺</span><span class="lbl">D</span></button>
              <button type="button" class="btn-tool" data-tool="circleG" title="Gólman (G)"><span class="ic">⚫</span><span class="lbl">G</span></button>
              <button type="button" class="btn-tool" data-tool="triangle" title="Trojúhelník"><span class="ic">🔻</span><span class="lbl">Kužel</span></button>
              <button type="button" class="btn-tool" data-tool="puck" title="Puk"><span class="ic">●</span><span class="lbl">Puk</span></button>
              <button type="button" class="btn-tool" data-tool="pucks" title="Zásoba puků"><span class="ic">●●</span><span class="lbl">Puky</span></button>
              <button type="button" class="btn-tool" data-tool="cone" title="Kužel"><span class="ic">▲</span><span class="lbl">Kužel</span></button>
              <label title="Barva útočníka (F)" style="display:inline-flex; align-items:center; gap:6px; font-size:12px;">
                <span class="lbl">F</span>
                <input type="color" id="colorF" value="#0000ff" style="width:28px; height:28px; padding:0; border:none; background:transparent;">
              </label>
              <label title="Barva obránce (D)" style="display:inline-flex; align-items:center; gap:6px; font-size:12px;">
                <span class="lbl">D</span>
                <input type="color" id="colorD" value="#ff0000" style="width:28px; height:28px; padding:0; border:none; background:transparent;">
              </label>
            </div>
            <div class="tool-group">
              <span class="group-title">Sync</span>
              <div style="margin-top:0; font-size:14px; display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
                 <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
                     <label id="lblSyncStart" class="toggle-label off" style="display:flex; align-items:center; gap:6px;" title="Spustit současný start hráčů (Play)">
                         <input type="checkbox" id="syncStart"> <span class="ic">▶</span> <span class="lbl">Začít synchronizaci hráčů</span>
                     </label>
                     <label id="lblSyncEnd" class="toggle-label off" style="display:flex; align-items:center; gap:6px;" title="Ukončit současný start hráčů (Stop)">
                         <input type="checkbox" id="syncEnd"> <span class="ic">⏹</span> <span class="lbl">Ukončit synchronizaci hráčů</span>
                     </label>
                     <span id="syncStatus" class="pill off">Současně: vypnuto</span>
                 </div>
                 <div class="hint-invert" style="width:100%; font-size:16px; opacity:0.95; color: var(--brand-secondary, #000);">Po „Začít“ budou všechny následující hráčské tahy (včetně jízdy s pukem) spuštěny současně. „Ukončit“ uzavře skupinu; další tahy už pojedou opět sekvenčně, dokud znovu nedáte „Začít“.</div>
              </div>
            </div>
        </div>

        <canvas id="board" class="rink-canvas"></canvas>
    </div>

    <input type="hidden" name="image_data" id="image_data">
    <input type="hidden" name="path_data" id="path_data">

    <p style="margin-top:15px;">
        <button type="button" class="btn-clear">🧹 Vymazat</button>
        <button type="button" class="btn-undo">↩️ Zpět</button>
        {% if is_coach %}
            <button type="submit" class="btn-save-drill">💾 Uložit cvičení</button>
        {% else %}
            <button type="button" disabled title="Uložení je dostupné jen pro trenéra">💾 Uložit cvičení</button>
        {% endif %}
    </p>
</form>
    <p style="margin-top:20px;"><a href="{{ url_for('drills') }}">← Zpět na seznam cvičení</a></p>

    <!-- Floating action button (mobile) to toggle toolbar visibility) -->
    <div class="fab-toolbar" aria-hidden="false">
      <button type="button" id="fabToggleToolbar" aria-label="Zobrazit/Skrýt nástroje">🛠</button>
    </div>

<script nonce="{{ csp_nonce }}">
let canvas = document.getElementById("board");
let ctx = canvas.getContext("2d");
let currentTool = "straight";
let drawing = false;
let startX, startY;
let pathPoints = [];
let history = [];
let drawData = []; // pro uložení cesty
let dataHistory = [];
let syncActive = false; // běžící skupina hráčských tahů
let syncCounter = 0;    // identifikátor skupiny

let rink = new Image();
rink.src = "/static/rink.png";
let manualSize = false;
function containerWidth(){
  try { return Math.max(600, Math.floor(canvas.parentElement.clientWidth)); } catch(_) { return 600; }
}
rink.onload = () => { resizeCanvas(containerWidth()); saveState(); };

// Dynamická velikost ikon a volitelné barvy F/D
const ICON_BASE = 25; // ~1.8× původní 18px
const TRI_BASE  = 25;
function _baseWidth(){ return (rink && rink.width) ? rink.width : 1400; }
function _displayWidth(){ try { return Math.max(1, canvas.getBoundingClientRect().width); } catch(_) { return canvas.width || 1; } }
function iconR(){ return Math.max(10, Math.round(ICON_BASE * (_displayWidth() / _baseWidth()))); }
function triR(){ return Math.max(10, Math.round(TRI_BASE  * (_displayWidth() / _baseWidth()))); }
let colorF = (localStorage.getItem('drillColorF') || '#0000ff');
let colorD = (localStorage.getItem('drillColorD') || '#ff0000');
try {
  const elF = document.getElementById('colorF');
  const elD = document.getElementById('colorD');
  if(elF){ elF.value = colorF; elF.addEventListener('input', e=>{ colorF = e.target.value || '#0000ff'; localStorage.setItem('drillColorF', colorF); }); }
  if(elD){ elD.value = colorD; elD.addEventListener('input', e=>{ colorD = e.target.value || '#ff0000'; localStorage.setItem('drillColorD', colorD); }); }
} catch(_) {}

const sizeInput = document.getElementById("canvasSize");
sizeInput.addEventListener("input", e => {
  manualSize = true;
  const w = parseInt(e.target.value, 10);
  // U slideru měníme jen vizuální (CSS) šířku canvasu,
  // nikoli jeho interní souřadnicový systém ani data.
  canvas.style.width = w + 'px';
  // Překresli, aby se přepočítala velikost ikon dle zobrazené šířky
  try { redrawAll(); } catch(_) {}
});

// Auto-resize na změnu okna – pokud uživatel ručně neupravil velikost a nic není nakresleno
let resizeTimer;
window.addEventListener('resize', function(){
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(function(){
    if(!manualSize){ resizeCanvas(containerWidth()); }
  }, 150);
});
 
  // Ovládání synchronizační skupiny
  document.addEventListener('DOMContentLoaded', ()=>{
  // Mobile toolbar show/hide toggle with persistence
  try {
    var tbar = document.getElementById('toolbar');
    var btnT = document.getElementById('btnToggleToolbarMobile');
    var btnTD = document.getElementById('btnToggleToolbarDesktop');
    var fabT = document.getElementById('fabToggleToolbar');
    var pref = localStorage.getItem('drillToolbarVisible');
    var visible = (pref === null) ? true : (pref === '1');
    function applyVis(){
      if(tbar){ tbar.classList.toggle('toolbar--hidden', !visible); }
      if(btnT){ btnT.textContent = visible ? 'Skrýt nástroje' : 'Zobrazit nástroje'; }
      if(btnTD){ btnTD.textContent = visible ? 'Skrýt nástroje' : 'Zobrazit nástroje'; }
      if(fabT){ fabT.setAttribute('aria-label', visible ? 'Skrýt nástroje' : 'Zobrazit nástroje'); }
    }
    applyVis();
    function toggleToolbar(){ visible = !visible; localStorage.setItem('drillToolbarVisible', visible ? '1' : '0'); applyVis(); }
    if(btnT){ btnT.addEventListener('click', toggleToolbar); }
    if(btnTD){ btnTD.addEventListener('click', toggleToolbar); }
    if(fabT){ fabT.addEventListener('click', toggleToolbar); }
  } catch(_){ }

  // Kompaktní režim toolbaru (persist přes localStorage)
  try {
    const toolbarEl = document.getElementById('toolbar');
    const compactChk = document.getElementById('compactToggle');
    const stored = localStorage.getItem('drillToolbarCompact') === '1';
    if(stored){ toolbarEl?.classList.add('toolbar--compact'); if(compactChk) compactChk.checked = true; }
    if(compactChk){
      compactChk.addEventListener('change', function(){
        if(compactChk.checked){ toolbarEl?.classList.add('toolbar--compact'); localStorage.setItem('drillToolbarCompact','1'); }
        else { toolbarEl?.classList.remove('toolbar--compact'); localStorage.removeItem('drillToolbarCompact'); }
      });
    }
  } catch(_) {}

  const startChk = document.getElementById('syncStart');
  const endChk = document.getElementById('syncEnd');
  const lblStart = document.getElementById('lblSyncStart');
  const lblEnd = document.getElementById('lblSyncEnd');
  const pill = document.getElementById('syncStatus');
  // dropped passSyncNext

  function updateSyncIndicators(){
    if(syncActive){
      lblStart.classList.add('active');
      lblEnd.classList.remove('active');
      lblStart.classList.remove('off');
      lblEnd.classList.add('off');
      pill.classList.remove('off');
      pill.classList.add('on');
      pill.textContent = 'Současně: zapnuto';
    } else {
      lblStart.classList.remove('active');
      lblEnd.classList.add('active');
      lblStart.classList.add('off');
      lblEnd.classList.remove('off');
      pill.classList.remove('on');
      pill.classList.add('off');
      pill.textContent = 'Současně: vypnuto';
    }
    // no passSyncNext
  }
  updateSyncIndicators();
  if(startChk){
    startChk.addEventListener('change', ()=>{
      if(startChk.checked){
        if(!syncActive){ syncCounter += 1; syncActive = true; }
        startChk.checked = false; // funguje jako tlačítko
        updateSyncIndicators();
      }
    });
  }
  if(endChk){
    endChk.addEventListener('change', ()=>{
      if(endChk.checked){ syncActive = false; endChk.checked = false; updateSyncIndicators(); }
    });
  }
  // no passSyncNext listener
  // inicializuj prázdný log
  try { renderSeqLog(); } catch(_) {}
});


function resizeCanvas(width) {
    const oldW = canvas.width || width;
    const oldH = canvas.height || ((width / rink.width) * rink.height);
    canvas.width = width;
    canvas.height = (canvas.width / rink.width) * rink.height;
    const sx = (oldW > 0) ? (canvas.width / oldW) : 1;
    const sy = (oldH > 0) ? (canvas.height / oldH) : 1;
    if (drawData && drawData.length) {
        scaleDrawData(sx, sy);
        redrawAll();
    } else {
        ctx.drawImage(rink, 0, 0, canvas.width, canvas.height);
    }
}

function setTool(t) { currentTool = t; }
function clearCanvas() { ctx.clearRect(0,0,canvas.width,canvas.height); ctx.drawImage(rink,0,0,canvas.width,canvas.height); drawData = []; saveState(); renderSeqLog(); }
function saveState() {
    history.push(canvas.toDataURL());
    dataHistory.push(JSON.stringify(drawData));
    if(history.length>30){ history.shift(); dataHistory.shift(); }
}
function undo() {
    if(history.length>1){
        history.pop();
        dataHistory.pop();
        const prevData = dataHistory.at(-1);
        try { drawData = JSON.parse(prevData || '[]'); } catch(_) { drawData = []; }
        let img=new Image();
        img.src=history.at(-1);
        img.onload=()=>{ctx.clearRect(0,0,canvas.width,canvas.height);ctx.drawImage(img,0,0,canvas.width,canvas.height);};
        renderSeqLog();
    }
}
// --- Minimal-size snapshot helper: overlay-only, downscaled WebP ---
function renderOverlayToContext(targetCtx){
  const prev = ctx;
  ctx = targetCtx;
  try {
    if(!drawData) return;
    for(const it of drawData){
      try{
        if(it.tool === 'player_move_puck' && it.path){
          // Wavy puck move
          drawWavyLine(it.path, 10, 40);
          const n = it.path.length;
          if(n>=2){ const [sx,sy]=it.path[n-2]; const [ex,ey]=it.path[n-1]; drawArrowHead(sx,sy,ex,ey,'black'); }
        } else if(it.tool === 'player_move' && it.path){
          const n = it.path.length;
          if(it.style === 'zigzag'){
            drawZigZagLine(it.path,10,40);
            if(n>=2){ const [sx,sy]=it.path[n-2]; const [ex,ey]=it.path[n-1]; drawArrowHead(sx,sy,ex,ey,'black'); }
          } else if(it.style === 'curve' || n > 2){
            drawCatmullRomLine(it.path);
            if(n>=2){ const [sx,sy]=it.path[n-2]; const [ex,ey]=it.path[n-1]; drawArrowHead(sx,sy,ex,ey,'black'); }
          } else if(n === 2){
            ctx.beginPath(); ctx.moveTo(it.path[0][0], it.path[0][1]); ctx.lineTo(it.path[1][0], it.path[1][1]); ctx.stroke();
            drawArrowHead(it.path[0][0], it.path[0][1], it.path[1][0], it.path[1][1], 'black');
          }
        } else if(it.tool === 'puck' && it.path){
          // pass/shot
          if(it.style === 'pass' || it.pass){ ctx.setLineDash([5,5]); }
          if(it.style === 'shot' || it.shot){ ctx.beginPath(); ctx.arc(it.path[0][0], it.path[0][1], 6, 0, 2*Math.PI); ctx.fill(); }
          ctx.beginPath(); ctx.moveTo(it.path[0][0], it.path[0][1]); ctx.lineTo(it.path[1][0], it.path[1][1]); ctx.stroke(); ctx.setLineDash([]);
          drawArrowHead(it.path[0][0], it.path[0][1], it.path[1][0], it.path[1][1], 'black');
        } else if(it.tool === 'puck_static' && typeof it.x==='number'){
          ctx.beginPath(); ctx.arc(it.x, it.y, 6, 0, 2*Math.PI); ctx.fill();
        } else if(it.tool === 'pucks_cluster' && typeof it.x==='number'){
          ctx.fillStyle = 'black';
          for(let i=-1;i<=1;i++){ for(let j=-1;j<=1;j++){ if(i||j){ ctx.beginPath(); ctx.arc(it.x+i*12, it.y+j*12, 5, 0, 2*Math.PI); ctx.fill(); } } }
          ctx.beginPath(); ctx.arc(it.x, it.y, 6, 0, 2*Math.PI); ctx.fill();
        } else if(it.tool === 'cone' && typeof it.x==='number'){
          ctx.fillStyle = 'orange'; ctx.beginPath(); ctx.moveTo(it.x, it.y); ctx.lineTo(it.x-10, it.y+20); ctx.lineTo(it.x+10, it.y+20); ctx.closePath(); ctx.fill();
        } else if(it.tool === 'triangle' && typeof it.x==='number'){
          ctx.fillStyle = 'purple'; ctx.beginPath(); ctx.moveTo(it.x, it.y-15); ctx.lineTo(it.x-15, it.y+15); ctx.lineTo(it.x+15, it.y+15); ctx.closePath(); ctx.fill();
        } else if(it.tool === 'player_icon' && typeof it.x==='number'){
          const label = it.role || 'F';
          const col = it.color || (label==='D' ? (typeof colorD!=='undefined'?colorD:'#ff0000') : (label==='F' ? (typeof colorF!=='undefined'?colorF:'#0000ff') : 'black'));
          if(label === 'D'){
            const R = triR();
            ctx.fillStyle=col; ctx.beginPath(); ctx.moveTo(it.x, it.y-R); ctx.lineTo(it.x-R, it.y+R); ctx.lineTo(it.x+R, it.y+R); ctx.closePath(); ctx.fill();
          } else {
            const R = iconR();
            ctx.beginPath(); ctx.arc(it.x, it.y, R, 0, 2*Math.PI); ctx.fillStyle=col; ctx.fill();
          }
        }
      }catch(_){ /* ignore item draw errors */ }
    }
  } finally {
    ctx = prev;
  }
}

function makeOverlayPreviewDataURL(maxWidth){
  const MAX_W = Math.max(600, maxWidth || 900);
  const s = Math.min(1, MAX_W / Math.max(1, canvas.width));
  const w = Math.round(canvas.width * s);
  const h = Math.round(canvas.height * s);
  const off = document.createElement('canvas');
  off.width = w; off.height = h;
  const oc = off.getContext('2d');
  // Draw rink background scaled to snapshot size to keep previews familiar
  try { oc.drawImage(rink, 0, 0, w, h); } catch(_) {}
  oc.save();
  oc.scale(s, s);
  renderOverlayToContext(oc);
  oc.restore();
  // Prefer WebP; browsers that don't support it will typically fallback to PNG
  let url = off.toDataURL('image/webp', 0.8);
  if(!/^data:image\/webp[,;]/.test(url)){
    // Fallback to JPEG with decent quality
    url = off.toDataURL('image/jpeg', 0.8);
  }
  return url;
}

function _dataWithMeta(){
  const meta = { tool: 'meta', canvas_w: canvas.width || 0, canvas_h: canvas.height || 0 };
  const arr = Array.isArray(drawData) ? drawData.slice() : [];
  if(arr.length && arr[0] && arr[0].tool === 'meta'){
    const copy = arr.slice();
    copy[0] = { ...(copy[0]||{}), canvas_w: meta.canvas_w, canvas_h: meta.canvas_h };
    return copy;
  }
  return [meta, ...arr];
}

function saveImage(){
  document.getElementById("image_data").value = makeOverlayPreviewDataURL(900);
  document.getElementById("path_data").value = JSON.stringify(_dataWithMeta());
} 

function getCanvasCoords(e){
  const rect = canvas.getBoundingClientRect();
  const scaleX = (canvas.width  || rect.width) / rect.width;
  const scaleY = (canvas.height || rect.height) / rect.height;
  if (e.touches && e.touches[0]) {
    const t = e.touches[0];
    return [ (t.clientX - rect.left) * scaleX, (t.clientY - rect.top) * scaleY ];
  }
  if (e.changedTouches && e.changedTouches[0]) {
    const t = e.changedTouches[0];
    return [ (t.clientX - rect.left) * scaleX, (t.clientY - rect.top) * scaleY ];
  }
  // Mouse events: use clientX/clientY (offsetX breaks with CSS scaling)
  const cx = e.clientX ?? 0; const cy = e.clientY ?? 0;
  return [ (cx - rect.left) * scaleX, (cy - rect.top) * scaleY ];
}

// Mouse
canvas.addEventListener("mousedown",e=>{drawing=true;[startX,startY]=getCanvasCoords(e);pathPoints=[[startX,startY]];ctx.beginPath();ctx.moveTo(startX,startY);});
canvas.addEventListener("mousemove",e=>{
    if(!drawing) return;
    let [x,y] = getCanvasCoords(e);
    if(["wave","zigzag"].includes(currentTool)){
        // Původní chování: při kreslení vykresluj jednoduchou linku
        pathPoints.push([x,y]);
        ctx.lineTo(x,y);
        ctx.strokeStyle = "black";
        ctx.lineWidth = 2;
        ctx.stroke();
    } else if(currentTool === "curve"){
        // Free draw – sbírej body, vyhladíme až na konci
        pathPoints.push([x,y]);
    }
});
canvas.addEventListener("mouseup",e=>{if(!drawing)return;drawing=false;let[x,y]=getCanvasCoords(e);handleDrawingEnd(x,y);saveState();});

// Touch
canvas.addEventListener("touchstart",e=>{e.preventDefault();drawing=true;[startX,startY]=getCanvasCoords(e);pathPoints=[[startX,startY]];ctx.beginPath();ctx.moveTo(startX,startY);}, {passive:false});
canvas.addEventListener("touchmove", e => {
    e.preventDefault();
    if(!drawing) return;
    let [x,y] = getCanvasCoords(e);
    // Na mobilu vždy udržuj poslední souřadnici, aby touchend znal cíl
    pathPoints.push([x,y]);
    if(["wave","zigzag"].includes(currentTool)){
        ctx.lineTo(x,y);
        ctx.strokeStyle = "black";
        ctx.lineWidth = 2;
        ctx.stroke();
    }
}, {passive:false});
canvas.addEventListener("touchend", e => {
    e.preventDefault();
    if(!drawing) return;
    drawing = false;
    let x = startX, y = startY;
    try {
      const coords = getCanvasCoords(e);
      if (coords && coords.length === 2) { x = coords[0]; y = coords[1]; }
      else if (pathPoints.length) { [x,y] = pathPoints.at(-1); }
    } catch(_) { if (pathPoints.length){ [x,y] = pathPoints.at(-1); } }
    handleDrawingEnd(x,y);
    saveState();
}, {passive:false});

// Přepočet dat při změně velikosti
function scaleDrawData(sx, sy){
  if(!drawData || !Array.isArray(drawData)) return;
  for(const it of drawData){
    if(it.path && Array.isArray(it.path)){
      for(let i=0;i<it.path.length;i++){
        it.path[i] = [ it.path[i][0] * sx, it.path[i][1] * sy ];
      }
    }
    if(typeof it.x === 'number' && typeof it.y === 'number'){
      it.x = it.x * sx; it.y = it.y * sy;
    }
  }
}

function redrawAll(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(rink,0,0,canvas.width,canvas.height);
  if(!drawData) return;
  for(const it of drawData){
    try{
      if(it.tool === 'player_move_puck' && it.path){
        // Wavy puck move
        drawWavyLine(it.path, 10, 40);
        const n = it.path.length;
        if(n>=2){ const [sx,sy]=it.path[n-2]; const [ex,ey]=it.path[n-1]; drawArrowHead(sx,sy,ex,ey,'black'); }
      } else if(it.tool === 'player_move' && it.path){
        const n = it.path.length;
        if(it.style === 'zigzag'){
          drawZigZagLine(it.path,10,40);
          if(n>=2){ const [sx,sy]=it.path[n-2]; const [ex,ey]=it.path[n-1]; drawArrowHead(sx,sy,ex,ey,'black'); }
        } else if(it.style === 'curve' || n > 2){
          drawCatmullRomLine(it.path);
          if(n>=2){ const [sx,sy]=it.path[n-2]; const [ex,ey]=it.path[n-1]; drawArrowHead(sx,sy,ex,ey,'black'); }
        } else if(n === 2){
          ctx.beginPath(); ctx.moveTo(it.path[0][0], it.path[0][1]); ctx.lineTo(it.path[1][0], it.path[1][1]); ctx.stroke();
          drawArrowHead(it.path[0][0], it.path[0][1], it.path[1][0], it.path[1][1], 'black');
        }
      } else if(it.tool === 'puck' && it.path){
        // pass/shot
        if(it.style === 'pass' || it.pass){ ctx.setLineDash([5,5]); }
        // draw small origin dot for shot
        if(it.style === 'shot' || it.shot){ ctx.beginPath(); ctx.arc(it.path[0][0], it.path[0][1], 6, 0, 2*Math.PI); ctx.fill(); }
        ctx.beginPath(); ctx.moveTo(it.path[0][0], it.path[0][1]); ctx.lineTo(it.path[1][0], it.path[1][1]); ctx.stroke(); ctx.setLineDash([]);
        drawArrowHead(it.path[0][0], it.path[0][1], it.path[1][0], it.path[1][1], 'black');
      } else if(it.tool === 'puck_static' && typeof it.x==='number'){
        ctx.beginPath(); ctx.arc(it.x, it.y, 6, 0, 2*Math.PI); ctx.fill();
      } else if(it.tool === 'pucks_cluster' && typeof it.x==='number'){
        ctx.fillStyle = 'black';
        for(let i=-1;i<=1;i++){ for(let j=-1;j<=1;j++){ if(i||j){ ctx.beginPath(); ctx.arc(it.x+i*12, it.y+j*12, 5, 0, 2*Math.PI); ctx.fill(); } } }
        ctx.beginPath(); ctx.arc(it.x, it.y, 6, 0, 2*Math.PI); ctx.fill();
      } else if(it.tool === 'cone' && typeof it.x==='number'){
        ctx.fillStyle = 'orange'; ctx.beginPath(); ctx.moveTo(it.x, it.y); ctx.lineTo(it.x-10, it.y+20); ctx.lineTo(it.x+10, it.y+20); ctx.closePath(); ctx.fill();
      } else if(it.tool === 'triangle' && typeof it.x==='number'){
        ctx.fillStyle = 'purple'; ctx.beginPath(); ctx.moveTo(it.x, it.y-15); ctx.lineTo(it.x-15, it.y+15); ctx.lineTo(it.x+15, it.y+15); ctx.closePath(); ctx.fill();
      } else if(it.tool === 'player_icon' && typeof it.x==='number'){
        const label = it.role || 'F';
        const col = it.color || (label==='D' ? (typeof colorD!=='undefined'?colorD:'#ff0000') : (label==='F' ? (typeof colorF!=='undefined'?colorF:'#0000ff') : 'black'));
        if(label === 'D'){
          const R = triR();
          ctx.fillStyle=col; ctx.beginPath(); ctx.moveTo(it.x, it.y-R); ctx.lineTo(it.x-R, it.y+R); ctx.lineTo(it.x+R, it.y+R); ctx.closePath(); ctx.fill();
        } else {
          const R = iconR();
          ctx.beginPath(); ctx.arc(it.x, it.y, R, 0, 2*Math.PI); ctx.fillStyle=col; ctx.fill();
        }
      }
    }catch(_){ /* ignore item draw errors */ }
  }
}

// -------------------------------
// Drawing logic + ukládání do drawData
// -------------------------------
function handleDrawingEnd(x,y){
    const tol = Math.max(2, canvas.width * 0.003);
    if(currentTool==="straight"){ ctx.beginPath();ctx.moveTo(startX,startY);ctx.lineTo(x,y);ctx.strokeStyle="black";ctx.lineWidth=2;ctx.stroke();drawArrowHead(startX,startY,x,y,"black"); const sg = syncActive ? syncCounter : null; const obj = {tool:"player_move",style:"straight",path:[[startX,startY],[x,y]]}; if(sg) obj.sync_group = sg; drawData.push(obj); }
    else if(currentTool==="curve"&&pathPoints.length>1){
        const sp = processCurvePath(pathPoints);
        drawCatmullRomLine(sp);
        const [ax,ay] = sp[sp.length-2] || sp[0];
        const [bx,by] = sp[sp.length-1];
        drawArrowHead(ax,ay,bx,by,"black");
        const syncGroup = syncActive ? syncCounter : null;
        const obj = {tool:"player_move",style:"curve",path:sp};
        if(syncGroup) obj.sync_group = syncGroup;
        drawData.push(obj);
    }
    else if(currentTool==="wave"&&pathPoints.length>1){
        // Původní chování: použij původní body bez vyhlazení
        drawWavyLine(pathPoints,10,40);
        let[sx,sy]=pathPoints.at(-2);
        drawArrowHead(sx,sy,x,y,"black");
        const syncGroup = syncActive ? syncCounter : null;
        const obj = {tool:"player_move_puck",style:"wavy",path:pathPoints};
        if(syncGroup) obj.sync_group = syncGroup;
        drawData.push(obj);
    }
    else if(currentTool==="zigzag"&&pathPoints.length>1){
        // Původní chování: použij původní body bez vyhlazení
        drawZigZagLine(pathPoints,10,40);
        let[sx,sy]=pathPoints.at(-2);
        drawArrowHead(sx,sy,x,y,"black");
        const syncGroup = syncActive ? syncCounter : null;
        const obj = {tool:"player_move",style:"zigzag",path:pathPoints};
        if(syncGroup) obj.sync_group = syncGroup;
        drawData.push(obj);
    }
    else if(currentTool==="double"){ctx.beginPath();ctx.arc(startX,startY,6,0,2*Math.PI);ctx.fill();ctx.beginPath();ctx.moveTo(startX,startY);ctx.lineTo(x,y);ctx.stroke();drawArrowHead(startX,startY,x,y,"black");drawData.push({tool:"puck",style:"shot",shot:true,sync_next:0,path:[[startX,startY],[x,y]]});}
    else if(currentTool==="dotted"){ctx.setLineDash([5,5]);ctx.beginPath();ctx.moveTo(startX,startY);ctx.lineTo(x,y);ctx.stroke();ctx.setLineDash([]);drawArrowHead(startX,startY,x,y,"black");drawData.push({tool:"puck",style:"pass",pass:true,sync_next:0,path:[[startX,startY],[x,y]]});}
    else if(currentTool==="puck"){ctx.beginPath();ctx.arc(x,y,6,0,2*Math.PI);ctx.fill();drawData.push({tool:"puck_static",x,y});}
    else if(currentTool==="pucks"){ctx.fillStyle="black";for(let i=-1;i<=1;i++){for(let j=-1;j<=1;j++){if(i||j){ctx.beginPath();ctx.arc(x+i*12,y+j*12,5,0,2*Math.PI);ctx.fill();}}}ctx.beginPath();ctx.arc(x,y,6,0,2*Math.PI);ctx.fill();drawData.push({tool:"pucks_cluster",x,y});}
    else if(currentTool==="cone"){ctx.fillStyle="orange";ctx.beginPath();ctx.moveTo(x,y);ctx.lineTo(x-10,y+20);ctx.lineTo(x+10,y+20);ctx.closePath();ctx.fill();drawData.push({tool:"cone",x,y});}
    else if(currentTool.startsWith("circle")){
        let label=(currentTool==="circleF")?"F":(currentTool==="circleD")?"D":"G";
        if(currentTool==="circleD"){
            // Obránce jako trojúhelník – barva a velikost dle nastavení
            const R = triR();
            ctx.fillStyle=(typeof colorD!=='undefined'?colorD:"red");
            ctx.beginPath();
            ctx.moveTo(x, y-R);
            ctx.lineTo(x-R, y+R);
            ctx.lineTo(x+R, y+R);
            ctx.closePath();
            ctx.fill();
        } else {
            // Útočník/Brankář jako kolečko – barva a velikost dle nastavení
            const R = iconR();
            ctx.beginPath();ctx.arc(x,y,R,0,2*Math.PI);
            ctx.fillStyle=(currentTool==="circleF")?(typeof colorF!=='undefined'?colorF:"blue"):"black";
            ctx.fill();
        }
        drawData.push({tool:"player_icon",role:label,x,y,color: (label==="D" ? (typeof colorD!=='undefined'?colorD:'#ff0000') : (label==="F" ? (typeof colorF!=='undefined'?colorF:'#0000ff') : 'black'))});
    }
    else if(currentTool==="triangle"){ctx.fillStyle="purple";ctx.beginPath();ctx.moveTo(x,y-15);ctx.lineTo(x-15,y+15);ctx.lineTo(x+15,y+15);ctx.closePath();ctx.fill();drawData.push({tool:"triangle",x,y});}
    renderSeqLog();
}

// Utility kreslení
function drawArrowHead(x1,y1,x2,y2,color){let a=Math.atan2(y2-y1,x2-x1);ctx.beginPath();ctx.moveTo(x2,y2);ctx.lineTo(x2-10*Math.cos(a-Math.PI/6),y2-10*Math.sin(a-Math.PI/6));ctx.lineTo(x2-10*Math.cos(a+Math.PI/6),y2-10*Math.sin(a+Math.PI/6));ctx.closePath();ctx.fillStyle=color;ctx.fill();}
function simplifyPath(points,tol){
    if(points.length<=2) return points.slice();
    const pts = points.map(p=>({x:p[0],y:p[1]}));
    function distToSeg(p,a,b){
        const A=p.x-a.x,B=p.y-a.y,C=b.x-a.x,D=b.y-a.y;
        const dot=A*C+B*D,len=C*C+D*D; const t=Math.max(0,Math.min(1,len?dot/len:0));
        const xx=a.x+t*C, yy=a.y+t*D; const dx=p.x-xx, dy=p.y-yy; return Math.hypot(dx,dy);
    }
    function rdp(arr, s, e, tol, out){
        let maxD=0, idx=-1;
        for(let i=s+1;i<e;i++){ const d=distToSeg(arr[i], arr[s], arr[e]); if(d>maxD){maxD=d;idx=i;} }
        if(maxD>tol && idx>0){ rdp(arr,s,idx,tol,out); rdp(arr,idx,e,tol,out); }
        else { out.push(arr[s]); }
    }
    const out=[]; rdp(pts,0,pts.length-1,tol,out); out.push(pts[pts.length-1]);
    return out.map(p=>[p.x,p.y]);
}
function processCurvePath(points){
    // 1) lehké zředění/normalizace krokem 3px pro menší kostrbatost
    const step = 3; // px
    let res = resamplePath(points, step);
    // 2) jemný klouzavý průměr (okno 1) – drží tvar, potlačí šum
    if(res.length > 2){
        const out=[]; const w=1;
        for(let i=0;i<res.length;i++){
            let sx=0, sy=0, c=0;
            for(let k=-w;k<=w;k++){
                const j=Math.min(res.length-1, Math.max(0,i+k)); sx+=res[j][0]; sy+=res[j][1]; c++;
            }
            out.push([sx/c, sy/c]);
        }
        res = out;
    }
    return res;
}
function drawCatmullRomLine(points){
    if(points.length < 2){ return; }
    ctx.beginPath();
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 2;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    // Duplicate endpoints for boundary conditions
    const pts = points.slice();
    const p0 = points[0];
    const pn = points[points.length-1];
    pts.unshift(p0);
    pts.push(pn);
    ctx.moveTo(points[0][0], points[0][1]);
    for(let i=1;i<pts.length-2;i++){
        const p0 = pts[i-1], p1 = pts[i], p2 = pts[i+1], p3 = pts[i+2];
        // Catmull-Rom to Bezier (uniform, s=1/6*1)
        const c1x = p1[0] + (p2[0]-p0[0]) / 6;
        const c1y = p1[1] + (p2[1]-p0[1]) / 6;
        const c2x = p2[0] - (p3[0]-p1[0]) / 6;
        const c2y = p2[1] - (p3[1]-p1[1]) / 6;
        ctx.bezierCurveTo(c1x, c1y, c2x, c2y, p2[0], p2[1]);
    }
    ctx.stroke();
}
function drawWavyLine(points,a,w){let r=resamplePath(points,5);ctx.beginPath();for(let i=1;i<r.length;i++){let[x1,y1]=r[i-1];let[x2,y2]=r[i];let ang=Math.atan2(y2-y1,x2-x1);let nx=-Math.sin(ang),ny=Math.cos(ang);let off=Math.sin((i*5)/w*2*Math.PI)*a;ctx.lineTo(x2+nx*off,y2+ny*off);}ctx.stroke();}
function drawZigZagLine(points,a,w){let r=resamplePath(points,w);ctx.beginPath();for(let i=0;i<r.length;i++){let[x,y]=r[i];if(i===0)ctx.moveTo(x,y);else{let[px,py]=r[i-1];let ang=Math.atan2(y-py,x-px);let nx=-Math.sin(ang),ny=Math.cos(ang);let off=(i%2===0?a:-a);ctx.lineTo(x+nx*off,y+ny*off);}}ctx.stroke();}
function resamplePath(points,step){let r=[points[0]],dist=0;for(let i=1;i<points.length;i++){let[x1,y1]=points[i-1];let[x2,y2]=points[i];let dx=x2-x1,dy=y2-y1;let len=Math.sqrt(dx*dx+dy*dy);let steps=Math.floor((dist+len)/step);for(let s=1;s<=steps;s++){let t=(s*step-dist)/len;if(t>=0&&t<=1)r.push([x1+dx*t,y1+dy*t]);}dist=(dist+len)%step;}return r;}

function saveImage() {
    document.getElementById("image_data").value = makeOverlayPreviewDataURL(900);
    document.getElementById("path_data").value = JSON.stringify(_dataWithMeta());  // ✅ ukládáme animaci s meta canvas size
}

// ----- Log sekvencí (současné skupiny) -----
function renderSeqLog(){
    let html = '';
    let seqNum = 0;
    let currentGroup = null; // {id, items:[]}
    function labelOf(it){
        if(it.tool === 'player_move_puck') return 'pohyb s pukem';
        if(it.tool === 'player_move') return 'pohyb bez puku';
        if(it.tool === 'puck') return it.shot ? 'střela' : 'nahrávka';
        return it.tool;
    }
    function flushGroup(){
        if(!currentGroup) return;
        seqNum += 1;
        const items = currentGroup.items.map(labelOf).join(', ');
        html += `<div>sekvence ${seqNum}: ${items}</div>`;
        currentGroup = null;
    }
    for(const it of drawData){
        const sg = parseInt(it.sync_group||0,10)||0;
        if(sg>0){
            if(!currentGroup || currentGroup.id !== sg){ flushGroup(); currentGroup = {id: sg, items: []}; }
            currentGroup.items.push(it);
        } else {
            flushGroup();
            seqNum += 1;
            html += `<div>sekvence ${seqNum}: ${labelOf(it)}</div>`;
        }
    }
    flushGroup();
    let logBox = document.getElementById('seqLog');
    if(!logBox){
        logBox = document.createElement('div');
        logBox.id = 'seqLog';
        logBox.style.marginTop = '10px';
        logBox.style.padding = '8px';
        logBox.style.border = '1px dashed #000';
        logBox.style.background = '#f8f8f8';
        logBox.style.color = '#000';
        canvas.parentElement.appendChild(logBox);
    }
    logBox.innerHTML = `<b>Log sekvencí:</b><div style="margin-top:6px; font-size:14px;">${html || '—'}</div>`;
}

</script>
{% endblock %}

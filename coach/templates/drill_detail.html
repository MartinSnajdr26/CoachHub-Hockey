{% extends "base.html" %}
{% block title %}{{ drill.name }}{% endblock %}

{% block content %}
<h1>{{ drill.name }}</h1>
<p><b>Kategorie:</b> {{ drill.category }}</p>
<p><b>Popis:</b> {{ drill.description }}</p>
<p><b>Doba:</b> {{ drill.duration }} min</p>

<!-- Canvas -->
<canvas id="board" style="border:2px solid #d4c76f; border-radius:8px; background:white;"></canvas>

<p style="margin-top:15px; display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
    <button onclick="playAnimation()">‚ñ∂Ô∏è P≈ôehr√°t</button>
    <button onclick="pauseAnimation()">‚è∏ Pauza</button>
    <button onclick="stopAnimation()">‚èπ Stop</button>
    <label style="margin-left:10px;">
        Re≈æim:
        <select id="animMode">
            <option value="sequential" selected>Sekvence</option>
            <option value="grouped">Skupiny (mezi ikonami)</option>
        </select>
    </label>
    <label style="margin-left:10px;">
        Sync po p≈ôihr√°vce:
        <select id="syncOverride">
            <option value="respect" selected>Respektovat (z editoru)</option>
            <option value="off">Vypnout</option>
            <option value="two">V≈ædy 2 pohyby</option>
        </select>
    </label>
    <label style="margin-left:10px;">
        P√°rov√°n√≠:
        <select id="pairMode">
            <option value="smart" selected>Chytr√©</option>
            <option value="order">Dle po≈ôad√≠ ikon</option>
            <option value="nearest">Dle nejbli≈æ≈°√≠ ikony</option>
        </select>
    </label>
    <label style="margin-left:10px; display:flex; align-items:center; gap:6px;">
        <input type="checkbox" id="showAnchors" checked>
        Kotvy
    </label>
    <button onclick="restartAndPlay()">‚ü≤ Restart + P≈ôehr√°t</button>
</p>

<form method="POST" action="{{ url_for('delete_drill', drill_id=drill.id) }}">
    <button type="submit" style="color:red;">üóë Smazat cviƒçen√≠</button>
</form>

<script>
    const canvas = document.getElementById("board");
    const ctx = canvas.getContext("2d");
    const rink = new Image();
    rink.src = "/static/rink.png";

    // Data z editoru ‚Äì robustn√≠ naƒçten√≠ i pro None/""/string
    const rawPathData = {{ drill.path_data | tojson | safe }}; // m≈Ø≈æe b√Ωt null nebo string JSON
    const rawImageData = {{ drill.image_data | tojson | safe }}; // base64 snapshot z editoru
    let drawData = [];
    if (Array.isArray(rawPathData)) {
        drawData = rawPathData;
    } else if (typeof rawPathData === 'string' && rawPathData.trim() !== '') {
        try { drawData = JSON.parse(rawPathData); } catch (_) { drawData = []; }
    }

    // Konfigurace animace
    const PLAYER_SPEED = 120; // px/s
    const PUCK_SPEED = 180;   // px/s
    let animMode = 'sequential'; // 'sequential' | 'grouped'
    let pairMode = 'smart';      // 'smart' | 'order' | 'nearest'
    let syncOverride = 'respect'; // 'respect' | 'off' | 'two'
    let showAnchors = true;      // zobrazovat start/stop/p≈ôihr√°vkov√© kotvy

    // Intern√≠ stav
    let animationFrame;
    let lastTimestamp;
    let globalTime = 0; // glob√°ln√≠ ƒças animace v sekund√°ch
    let paused = false;
    let totalDuration = 0; // d√©lka cel√© animace
    const moves = [];    // {kind:'player'|'puck', points, length, start, duration, role, entityId?, lastOfEntity?}
    const statics = [];  // polo≈æky, kter√© se prostƒõ vykresl√≠
    const initialByEntity = new Map(); // entityId -> {x, y, role}
    const finalByEntity = new Map();   // entityId -> {end, x, y, role}
    const passAnchors = [];            // {x, y, role, tStart, tEnd, tHide, entityId}
    const anchorsPermanent = [];       // trval√© kotvy: {x, y, role, t, tHide}

    // Rozhodnut√≠ velikosti canvasu: preferuj ulo≈æen√Ω snapshot z editoru
    let sizeDecided = false;
    const savedImg = new Image();
    if (typeof rawImageData === 'string' && rawImageData.startsWith('data:image')) {
        savedImg.onload = () => decideSize(savedImg.width, savedImg.height);
        savedImg.src = rawImageData;
    }
    rink.onload = () => {
        if (!sizeDecided) {
            // fallback na ≈°√≠≈ôku  min(sn√≠mek, 1000) nebo 1000, kdy≈æ nen√≠ snapshot
            decideSize(1000, (1000 / rink.width) * rink.height);
        }
    };

    function decideSize(w, h){
        if (sizeDecided) return;
        sizeDecided = true;
        canvas.width = Math.max(1, Math.round(w));
        canvas.height = Math.max(1, Math.round(h));
        drawBackground();
        prepareAnimation();
        renderFrame(0);
    }

    function drawBackground() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(rink, 0, 0, canvas.width, canvas.height);
    }

    function distance(a, b){ const dx=b.x-a.x, dy=b.y-a.y; return Math.hypot(dx,dy); }

    function annotateCumulative(points){
        let acc = 0; const out = [{...points[0], s:0}];
        for(let i=1;i<points.length;i++){ acc += distance(points[i-1], points[i]); out.push({...points[i], s:acc}); }
        return {points: out, length: acc};
    }

    // Nav√°≈æe nejbli≈æ≈°√≠ p≈ôedchoz√≠ ikonu hr√°ƒçe jako roli k n√°sleduj√≠c√≠mu pathu
    function prepareAnimation(){
        moves.length = 0; statics.length = 0; finalByEntity.clear(); passAnchors.length = 0; anchorsPermanent.length = 0;
        let pendingRole = null;
        let currentEntityId = 0; // identifik√°tor hr√°ƒçe dle posledn√≠ ikony
        const icons = []; // seznam ikon: {eid, role, x, y, idx}
        const entities = new Map(); // eid -> {role, x, y}

        function nearestIconForPath(startX, startY, maxIdx){
            let best = null; let bestDist = Infinity;
            const radius = Math.max(20, canvas.width * 0.012);
            for(const ic of icons){
                if(ic.idx > maxIdx) continue;
                const d = Math.hypot(ic.x - startX, ic.y - startY);
                if(d < radius && d < bestDist){ best = ic; bestDist = d; }
            }
            if(!best){
                // fallback na absolutnƒõ nejbli≈æ≈°√≠ p≈ôedchoz√≠ ikonu
                for(const ic of icons){
                    if(ic.idx > maxIdx) continue;
                    const d = Math.hypot(ic.x - startX, ic.y - startY);
                    if(d < bestDist){ best = ic; bestDist = d; }
                }
            }
            return best; // m≈Ø≈æe b√Ωt null
        }

        function nearestEntityCurrent(startX, startY){
            let best = null; let bestDist = Infinity;
            for(const [eid, ent] of entities.entries()){
                const d = Math.hypot(ent.x - startX, ent.y - startY);
                if(d < bestDist){ best = {eid, role: ent.role, x: ent.x, y: ent.y}; bestDist = d; }
            }
            return best;
        }

        function assignEntityForPath(points, idx, pendingRole, currentEntityId, lastPass){
            // returns {eid, role}
            // priority (smart): last pass recipient near start -> nearest icon -> order
            if(pairMode === 'order'){
                return { eid: (currentEntityId || null), role: pendingRole };
            }
            const start = points[0];
            if(pairMode === 'smart'){
                if(lastPass && lastPass.eid != null){
                    const ent = entities.get(lastPass.eid);
                    if(ent){
                        const d = Math.hypot(start.x - ent.x, start.y - ent.y);
                        const r = Math.max(20, canvas.width * 0.012);
                        if(d < r) return { eid: lastPass.eid, role: ent.role };
                    }
                }
            }
            // prefer aktu√°ln√≠ pozici figurky (≈°achovnicov√° logika)
            const nEnt = nearestEntityCurrent(start.x, start.y);
            if(nEnt) return { eid: nEnt.eid, role: nEnt.role };
            // fallback: pozice nejbli≈æ≈°√≠ ikony
            const nearest = nearestIconForPath(start.x, start.y, idx);
            if(nearest) return { eid: nearest.eid, role: nearest.role };
            // fallback
            return { eid: (currentEntityId || null), role: pendingRole };
        }

        if (animMode === 'sequential') {
            let currentTime = 0; // akumuluje ƒças tak, jak jste kreslil
            let lastPass = null;  // {eid, role, x, y}
            let syncAfterPass = null; // {start, maxDur, remaining}
            // Jednoduch√Ω stav pr√°vƒõ otev≈ôen√© synchronn√≠ skupiny ‚Äì aby se dal≈°√≠ tahy pl√°novaly a≈æ po n√≠
            let currentGroup = null; // {id, start, maxEnd}

            function iconHasUpcomingMove(fromIndex){
                for(let k=fromIndex+1;k<drawData.length;k++){
                    const it = drawData[k];
                    if(it.tool === 'player_icon') return false;
                    if((it.tool === 'player_move' || it.tool === 'player_move_puck') && it.path) return true;
                }
                return false;
            }

            for(let idx=0; idx<drawData.length; idx++){
                const item = drawData[idx];
                if(item.tool === 'player_icon'){
                    pendingRole = item.role || null;
                    currentEntityId += 1;
                    initialByEntity.set(currentEntityId, {x: item.x, y: item.y, role: pendingRole});
                    entities.set(currentEntityId, {x: item.x, y: item.y, role: pendingRole});
                    icons.push({eid: currentEntityId, role: pendingRole, x: item.x, y: item.y, idx});
                    if(!iconHasUpcomingMove(idx)) statics.push(item);
                } else if(item.tool === 'puck_static'){
                    statics.push(item);
                } else if(item.tool === 'cone' || item.tool === 'triangle' || item.tool === 'pucks_cluster'){
                    statics.push(item);
                } else if((item.tool === 'player_move' || item.tool === 'player_move_puck') && item.path){
                    const pts = item.path.map(p=>({x:p[0], y:p[1]}));
                    if(pts.length < 2) continue;
                    const {points, length} = annotateCumulative(pts);
                    const duration = Math.max(0.001, length / PLAYER_SPEED);
                    const assigned = assignEntityForPath(points, idx, pendingRole, currentEntityId, lastPass);
                    const withPuck = (item.tool === 'player_move_puck');
                    let startTime = syncAfterPass ? syncAfterPass.start : currentTime;
                    const sg = parseInt(item.sync_group||0, 10) || 0;
                    // Spr√°va pr√°vƒõ otev≈ôen√© synchronn√≠ skupiny
                    if(sg>0){
                        if(!currentGroup){
                            // otev≈ôi novou skupinu v aktu√°ln√≠m ƒçase
                            currentGroup = { id: sg, start: startTime, maxEnd: startTime };
                        } else if(currentGroup.id !== sg){
                            // uzav≈ôi p≈ôedchoz√≠ skupinu, posu≈à ƒças a zaƒçni novou
                            currentTime = Math.max(currentTime, currentGroup.maxEnd);
                            startTime = currentTime;
                            currentGroup = { id: sg, start: startTime, maxEnd: startTime };
                        } else {
                            // pokraƒçuj v r√°mci stejn√© skupiny
                            startTime = currentGroup.start;
                        }
                    } else if(currentGroup){
                        // p≈ôi p≈ôechodu ze skupiny na neseskupen√© ‚Äì uzav≈ôi skupinu a posu≈à ƒças
                        currentTime = Math.max(currentTime, currentGroup.maxEnd);
                        startTime = currentTime;
                        currentGroup = null;
                    }
                    const moveObj = {kind:'player', role: assigned.role, points, length, start: startTime, duration, entityId: assigned.eid, withPuck, sync_group: sg};
                    moves.push(moveObj);
                    // aktualizuj maxim√°ln√≠ konec pro pr√°vƒõ otev≈ôenou skupinu
                    if(sg>0 && currentGroup){
                        const end = startTime + duration;
                        if(end > currentGroup.maxEnd) currentGroup.maxEnd = end;
                    }
                    // posu≈à aktu√°ln√≠ pozici figurky na konec tahu
                    if(assigned.eid != null){ const endPt = points[points.length-1]; const ent = entities.get(assigned.eid); if(ent){ ent.x = endPt.x; ent.y = endPt.y; } }
                    if(syncAfterPass){
                        syncAfterPass.maxDur = Math.max(syncAfterPass.maxDur, duration);
                        syncAfterPass.remaining -= 1;
                        if(syncAfterPass.remaining <= 0){
                            currentTime = Math.max(currentTime, syncAfterPass.start + syncAfterPass.maxDur);
                            syncAfterPass = null;
                        }
                    } else {
                        // mimo skupinu posouvej ƒças bƒõ≈ænƒõ
                        if(!(sg>0)) currentTime += duration;
                    }
                } else if(item.tool === 'puck' && item.path){
                    const pts = item.path.map(p=>({x:p[0], y:p[1]}));
                    if(pts.length < 2) continue;
                    const {points, length} = annotateCumulative(pts);
                    const duration = Math.max(0.001, length / PUCK_SPEED);
                    // pokud je zrovna otev≈ôen√° skupina hr√°ƒç≈Ø, uzav≈ôi ji p≈ôed pl√°nov√°n√≠m p≈ôihr√°vky/st≈ôely
                    if(currentGroup){
                        currentTime = Math.max(currentTime, currentGroup.maxEnd);
                        currentGroup = null;
                    }
                    // nastav p≈ô√≠jemce pro chytr√© p√°rov√°n√≠ dal≈°√≠ho tahu (podle c√≠le p≈ôihr√°vky)
                    lastPass = null;
                    if(pairMode !== 'order'){
                        const endPt = points[points.length-1];
                        // zkus naj√≠t p≈ô√≠jemce podle aktu√°ln√≠ch pozic figur
                        const rec = nearestEntityCurrent(endPt.x, endPt.y) || nearestIconForPath(endPt.x, endPt.y, idx);
                        if(rec) lastPass = { eid: rec.eid, role: rec.role, x: endPt.x, y: endPt.y };
                    }
                    moves.push({kind:'puck', role:null, points, length, start: currentTime, duration});
                    // per-pass sync: podle override v UI nebo flagu z editoru
                    let syncNextCount = 0;
                    if(syncOverride === 'two') syncNextCount = 2;
                    else if(syncOverride === 'respect') syncNextCount = parseInt(item.sync_next||0, 10) || 0;
                    else syncNextCount = 0;
                    if(syncNextCount > 0){
                        const passEnd = currentTime + duration;
                        currentTime = passEnd; // posu≈à ƒças na konec p≈ôihr√°vky
                        syncAfterPass = { start: passEnd, maxDur: 0, remaining: syncNextCount };
                    } else {
                        currentTime += duration;
                    }
                }
            }
            // Uzav≈ôi p≈ô√≠padnou posledn√≠ skupinu
            if(currentGroup){
                currentTime = Math.max(currentTime, currentGroup.maxEnd);
                currentGroup = null;
            }
            totalDuration = currentTime;
        } else {
            // grouped: v≈°e od ikony po dal≈°√≠ ikonu bƒõ≈æ√≠ souƒçasnƒõ; skupiny jdou za sebou
            let groupStart = 0;
            let groupMoves = [];
            let groupIcon = null; // posledn√≠ ikona, kter√° skupinu zah√°jila
            let pendingSync = null; // {start, remaining, maxDur}
            const groupStates = new Map(); // sync_group -> {start}

            function flushGroup(){
                if(groupMoves.length === 0){
                    // nic k animaci ‚Äì pokud je tu ikona, uka≈æ ji staticky
                    if(groupIcon) statics.push(groupIcon);
                    return; 
                }
                // nastav start podle p≈ô√≠padn√Ωch override a spoƒç√≠tej konec cel√© skupiny
                let maxEnd = groupStart;
                for(const m of groupMoves){
                    const s = (m.startOverride != null) ? m.startOverride : groupStart;
                    m.start = s; moves.push(m);
                    const end = s + m.duration; if(end > maxEnd) maxEnd = end;
                }
                groupStart = maxEnd; // dal≈°√≠ skupina zaƒçne po skonƒçen√≠ t√©to (vƒçetnƒõ paraleln√≠ch override)
                groupMoves = []; groupIcon = null;
                pendingSync = null;
            }

            for(let idx=0; idx<drawData.length; idx++){
                const item = drawData[idx];
                if(item.tool === 'player_icon'){
                    flushGroup();
                    pendingRole = item.role || null;
                    currentEntityId += 1;
                    initialByEntity.set(currentEntityId, {x: item.x, y: item.y, role: pendingRole});
                    entities.set(currentEntityId, {x: item.x, y: item.y, role: pendingRole});
                    icons.push({eid: currentEntityId, role: pendingRole, x: item.x, y: item.y, idx});
                    groupIcon = item;
                } else if(item.tool === 'puck_static'){
                    // statick√° souƒç√°st ‚Äì nez√°visl√° na skupin√°ch
                    statics.push(item);
                } else if(item.tool === 'cone' || item.tool === 'triangle' || item.tool === 'pucks_cluster'){
                    statics.push(item);
                } else if((item.tool === 'player_move' || item.tool === 'player_move_puck') && item.path){
                    const pts = item.path.map(p=>({x:p[0], y:p[1]}));
                    if(pts.length < 2) continue;
                    const {points, length} = annotateCumulative(pts);
                    const duration = Math.max(0.001, length / PLAYER_SPEED);
                    const assigned = assignEntityForPath(points, idx, pendingRole, currentEntityId, null);
                    const withPuck = (item.tool === 'player_move_puck');
                    let startOverride = null;
                    const sg = parseInt(item.sync_group||0, 10) || 0;
                    if(sg>0){ if(!groupStates.has(sg)) groupStates.set(sg, {start: groupStart}); startOverride = groupStates.get(sg).start; }
                    const moveObj = {kind:'player', role: assigned.role, points, length, duration, entityId: assigned.eid, withPuck};
                    if(startOverride!=null) moveObj.startOverride = startOverride;
                    if(pendingSync){
                        moveObj.startOverride = pendingSync.start;
                        pendingSync.maxDur = Math.max(pendingSync.maxDur, duration);
                        pendingSync.remaining -= 1;
                        if(pendingSync.remaining <= 0){
                            // pendingSync resolved; groupStart will be adjusted in flushGroup via maxEnd
                            pendingSync = null;
                        }
                    }
                    groupMoves.push(moveObj);
                } else if(item.tool === 'puck' && item.path){
                    const pts = item.path.map(p=>({x:p[0], y:p[1]}));
                    if(pts.length < 2) continue;
                    const {points, length} = annotateCumulative(pts);
                    const duration = Math.max(0.001, length / PUCK_SPEED);
                    const passObj = {kind:'puck', role:null, points, length, duration};
                    groupMoves.push(passObj);
                    let syncNextCount = 0;
                    if(syncOverride === 'two') syncNextCount = 2;
                    else if(syncOverride === 'respect') syncNextCount = parseInt(item.sync_next||0, 10) || 0;
                    else syncNextCount = 0;
                    if(syncNextCount > 0){
                        const passEnd = groupStart + duration; // pass start is groupStart in this group
                        // nastav pending sync pro dal≈°√≠ N hr√°ƒçsk√Ωch tah≈Ø
                        pendingSync = { start: passEnd, remaining: syncNextCount, maxDur: 0 };
                    }
                }
            }
            flushGroup();
            totalDuration = groupStart;
        }
        // Po sestaven√≠ tah≈Ø spoƒç√≠tej fin√°ln√≠ stav hr√°ƒçe (konec posledn√≠ho tahu)
        const byEntity = new Map();
        for(const m of moves){
            if(m.kind !== 'player' || m.entityId == null) continue;
            const end = (m.start ?? 0) + m.duration;
            const lastPt = m.points[m.points.length - 1];
            const cur = byEntity.get(m.entityId);
            if(!cur || end > cur.end){
                byEntity.set(m.entityId, {end, x: lastPt.x, y: lastPt.y, role: m.role});
            }
        }
        for(const [eid, info] of byEntity.entries()) finalByEntity.set(eid, info);
        // P≈ôidej doƒçasn√© kotvy pro p≈ôihr√°vky: bƒõhem letu puku nech ikonu hr√°ƒçe na zaƒç√°tku p≈ôihr√°vky
        // Odvod√≠me roli a pozici z nejbli≈æ≈°√≠ho p≈ôedchoz√≠ho konce pohybu hr√°ƒçe pobl√≠≈æ startu p≈ôihr√°vky
        const playerEnds = [];
        const playerMovesByEntity = new Map(); // entityId -> [{start, duration}]
        for(const pm of moves){
            if(pm.kind !== 'player') continue;
            const endT = pm.start + pm.duration;
            const endPt = pm.points[pm.points.length - 1];
            playerEnds.push({t:endT, x:endPt.x, y:endPt.y, role: pm.role || 'F', entityId: pm.entityId});
            if(pm.entityId != null){
                if(!playerMovesByEntity.has(pm.entityId)) playerMovesByEntity.set(pm.entityId, []);
                playerMovesByEntity.get(pm.entityId).push({start: pm.start, duration: pm.duration});
            }
        }
        // se≈ôaƒè starty u hr√°ƒç≈Ø
        for(const arr of playerMovesByEntity.values()) arr.sort((a,b)=>a.start-b.start);

        // P≈ôidej koncov√© kotvy po ka≈æd√©m hr√°ƒçovƒõ tahu ‚Äì z≈Østanou do zaƒç√°tku dal≈°√≠ho pohybu stejn√©ho hr√°ƒçe
        for(const m of moves){
            if(m.kind !== 'player' || m.entityId == null) continue;
            const info = finalByEntity.get(m.entityId);
            const end = (m.start ?? 0) + m.duration;
            m.lastOfEntity = info && Math.abs(end - info.end) < 1e-6;
            const endPt = m.points[m.points.length - 1];
            const seq = (m.entityId != null) ? (playerMovesByEntity.get(m.entityId) || []) : [];
            let nextStart = Infinity;
            for(const mv of seq){ if(mv.start > (m.start ?? 0) + 1e-6){ nextStart = mv.start; break; } }
            anchorsPermanent.push({x: endPt.x, y: endPt.y, role: m.role || 'F', t: end, tHide: nextStart});
        }

        // Po sestaven√≠ tah≈Ø p≈ôidej startovn√≠ kotvy s tHide = zaƒç√°tek prvn√≠ho pohybu hr√°ƒçe (pokud existuje)
        for(const [eid, init] of initialByEntity.entries()){
            let tHide = Infinity;
            const seq = playerMovesByEntity.get(eid) || [];
            if(seq.length){ tHide = seq[0].start; }
            anchorsPermanent.push({x: init.x, y: init.y, role: init.role || 'F', t: 0, tHide});
        }
        function nearestEndBefore(tStart, x0, y0){
            let best = null; let bestDt = Infinity; let bestDist = Infinity;
            for(const e of playerEnds){
                if(e.t > tStart + 1e-6) continue;
                const dist = Math.hypot(e.x - x0, e.y - y0);
                const dt = tStart - e.t;
                const radius = Math.max(15, canvas.width * 0.01);
                if(dist < radius && (dt < bestDt || (Math.abs(dt-bestDt)<1e-6 && dist < bestDist))){ best = e; bestDt = dt; bestDist = dist; }
            }
            return best;
        }

        function activePlayerAt(time){
            let found = null;
            for(const mv of moves){
                if(mv.kind !== 'player') continue;
                if(time >= mv.start && time < mv.start + mv.duration){
                    if(!found || mv.start > found.start) found = mv;
                }
            }
            return found;
        }
        let lastKnownRole = null;
        for(const m of moves){
            if(m.kind === 'player') lastKnownRole = m.role || lastKnownRole;
            if(m.kind !== 'puck' || m.entityId != null) continue; // samostatn√° p≈ôihr√°vka
            const tStart = m.start, tEnd = m.start + m.duration;
            const startPt = m.points[0];
            const active = activePlayerAt(tStart);
            const match = active ? { role: active.role || 'F', entityId: active.entityId } : nearestEndBefore(tStart, startPt.x, startPt.y);
            const role = (match && match.role) || lastKnownRole || 'F';
            let tHide = Infinity;
            if(match && match.entityId != null){
                const seq = playerMovesByEntity.get(match.entityId) || [];
                for(const mv of seq){
                    if(mv.start + 1e-6 >= tEnd){ tHide = mv.start; break; }
                }
            }
            passAnchors.push({x: startPt.x, y: startPt.y, role, tStart, tEnd, tHide, entityId: match ? match.entityId : null});
        }
    }

    function drawStatics(){
        for(const it of statics){
            if(it.tool === 'player_icon'){
                drawRoleCircle(it.role || '?', it.x, it.y);
            } else if(it.tool === 'puck_static'){
                ctx.beginPath(); ctx.arc(it.x, it.y, 6, 0, 2*Math.PI); ctx.fillStyle = 'black'; ctx.fill();
            } else if(it.tool === 'cone'){
                ctx.fillStyle = 'orange'; ctx.beginPath(); ctx.moveTo(it.x, it.y); ctx.lineTo(it.x-10, it.y+20); ctx.lineTo(it.x+10, it.y+20); ctx.closePath(); ctx.fill();
            } else if(it.tool === 'triangle'){
                ctx.fillStyle = 'purple'; ctx.beginPath(); ctx.moveTo(it.x, it.y-15); ctx.lineTo(it.x-15, it.y+15); ctx.lineTo(it.x+15, it.y+15); ctx.closePath(); ctx.fill();
            } else if(it.tool === 'pucks_cluster'){
                ctx.fillStyle = 'black';
                for(let i=-1;i<=1;i++) for(let j=-1;j<=1;j++){ if(i||j){ ctx.beginPath(); ctx.arc(it.x+i*12, it.y+j*12, 5, 0, 2*Math.PI); ctx.fill(); } }
                ctx.beginPath(); ctx.arc(it.x, it.y, 6, 0, 2*Math.PI); ctx.fill();
            }
        }
    }

    // Z√°mƒõrnƒõ nerysujeme podkladov√© trasy ‚Äì v animaci se zobrazuj√≠ jen ikony hr√°ƒçe a puk

    function drawRoleCircle(role, x, y, alpha=1){
        const color = role === 'F' ? 'blue' : role === 'D' ? 'red' : 'black';
        ctx.save();
        ctx.globalAlpha = Math.max(0, Math.min(1, alpha));
        ctx.beginPath(); ctx.arc(x, y, 18, 0, 2*Math.PI); ctx.fillStyle = color; ctx.fill();
        ctx.fillStyle = 'white'; ctx.font = '12px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(role || '?', x, y);
        ctx.restore();
    }

    function positionAt(m, elapsed){
        // elapsed v sekund√°ch -> ujet√° vzd√°lenost
        const dist = Math.min(elapsed / m.duration * m.length, m.length);
        // najdi segment
        let i = 1; while(i < m.points.length && m.points[i].s < dist) i++;
        if(i >= m.points.length) return m.points[m.points.length-1];
        const a = m.points[i-1], b = m.points[i];
        const segLen = b.s - a.s || 1;
        const t = (dist - a.s) / segLen;
        return {x: a.x + (b.x - a.x)*t, y: a.y + (b.y - a.y)*t};
    }

    function renderFrame(dt){
        globalTime += dt;
        drawBackground();
        drawStatics();
        // bez podkladov√Ωch ƒçar ‚Äì pouze ikony a puk
        // Vykresli pohybliv√© objekty ‚Äì hr√°ƒç je v≈ædy viditeln√Ω: p≈ôed prvn√≠m tahem na startu,
        // bƒõhem tahu se h√Ωbe, po konci z≈Øst√°v√° na konci posledn√≠ho dokonƒçen√©ho tahu
        const entityIds = new Set();
        for(const m of moves){ if(m.kind === 'player' && m.entityId != null) entityIds.add(m.entityId); }
        for(const eid of initialByEntity.keys()) entityIds.add(eid);

        for(const eid of entityIds){
            // aktivn√≠ tah (pokud bƒõ≈æ√≠)
            let active = null;
            for(const m of moves){
                if(m.kind !== 'player' || m.entityId !== eid) continue;
                if(globalTime >= m.start && globalTime < m.start + m.duration){ if(!active || m.start > active.start) active = m; }
            }

            if(active){
                const t = globalTime - active.start; // 0..duration
                const pos = positionAt(active, t);
                // bez fade efektu
                drawRoleCircle(active.role || (initialByEntity.get(eid)?.role) || 'F', pos.x, pos.y, 1);
                continue;
            }

            // nen√≠ aktivn√≠ ‚Äì hledej posledn√≠ dokonƒçen√Ω tah do aktu√°ln√≠ho ƒçasu
            let latest = null;
            for(const m of moves){
                if(m.kind !== 'player' || m.entityId !== eid) continue;
                const end = m.start + m.duration;
                if(globalTime + 1e-6 >= end){ if(!latest || end > (latest.start + latest.duration)) latest = m; }
            }
            if(latest){
                const lastPt = latest.points[latest.points.length - 1];
                drawRoleCircle(latest.role || (initialByEntity.get(eid)?.role) || 'F', lastPt.x, lastPt.y, 1);
                continue;
            }

            // p≈ôed prvn√≠m tahem ‚Äì poƒç√°teƒçn√≠ ikona
            const init = initialByEntity.get(eid);
            if(init){ drawRoleCircle(init.role || 'F', init.x, init.y, 1); }
        }

        // 2) Puky: pro j√≠zdu s pukem jsou ‚Äûp≈ôilepen√©‚Äú k hr√°ƒçi (stejn√° pozice); samostatn√© puky kresli z path
        // Puk s hr√°ƒçem
        for(const m of moves){
            if(m.kind !== 'player' || !m.withPuck) continue;
            if(globalTime < m.start || globalTime >= m.start + m.duration) continue;
            const t = globalTime - m.start;
            const pos = positionAt(m, t);
            ctx.beginPath(); ctx.arc(pos.x, pos.y, 6, 0, 2*Math.PI); ctx.fillStyle = 'black'; ctx.fill();
        }
        // samostatn√© (nep≈ôi≈ôazen√©) puky
        for(const m of moves){
            if(m.kind !== 'puck' || m.entityId != null) continue; // samostatn√© puky (p≈ôihr√°vky/st≈ôely)
            if(globalTime < m.start || globalTime >= m.start + m.duration) continue;
            const t = globalTime - m.start;
            const pos = positionAt(m, t);
            ctx.beginPath(); ctx.arc(pos.x, pos.y, 6, 0, 2*Math.PI); ctx.fillStyle = 'black'; ctx.fill();
        }
        if(showAnchors){
            // 3) Ikona hr√°ƒçe na zaƒç√°tku p≈ôihr√°vky: zobraz od zaƒç√°tku do zaƒç√°tku dal≈°√≠ho pohybu stejn√©ho hr√°ƒçe (pokud existuje)
            for(const a of passAnchors){ if(globalTime + 1e-6 >= a.tStart && globalTime < a.tHide - 1e-6){ drawRoleCircle(a.role || 'F', a.x, a.y, 1); } }
            // 4) Trval√© kotvy (starty s tHide a konce s tHide)
            for(const a of anchorsPermanent){ if(globalTime + 1e-6 >= a.t && globalTime < (a.tHide ?? Infinity) - 1e-6){ drawRoleCircle(a.role || 'F', a.x, a.y, 1); } }
        }
        // Bez dodateƒçn√Ωch kotev ‚Äì zobrazuje se pouze aktivn√≠/posledn√≠ stav hr√°ƒçe
        if(totalDuration && globalTime >= totalDuration){
            // dokonƒçi ‚Äì ponech zobrazen√© fin√°ln√≠ ikony
            if(animationFrame) cancelAnimationFrame(animationFrame);
            animationFrame = null;
        }
    }

    function loop(ts){
        if(lastTimestamp == null) lastTimestamp = ts;
        const dt = (ts - lastTimestamp) / 1000; // v sekund√°ch
        lastTimestamp = ts;
        renderFrame(dt);
        animationFrame = requestAnimationFrame(loop);
    }

    function resetAnimation(){
        lastTimestamp = undefined;
        globalTime = 0;
    }

    // Ovl√°d√°n√≠
    function playAnimation(){
        if(animationFrame) return; // u≈æ bƒõ≈æ√≠
        if(paused){ paused = false; animationFrame = requestAnimationFrame(loop); return; }
        resetAnimation();
        animationFrame = requestAnimationFrame(loop);
    }
    function pauseAnimation(){ if(animationFrame){ cancelAnimationFrame(animationFrame); animationFrame = null; paused = true; } }
    function stopAnimation(){
        if(animationFrame) cancelAnimationFrame(animationFrame);
        animationFrame = null;
        paused = false;
        // po zastaven√≠ vyƒçisti pl√°tno (≈æ√°dn√° ikona ani puk na plo≈°e)
        drawBackground();
    }
    function restartAndPlay(){ stopAnimation(); prepareAnimation(); resetAnimation(); animationFrame = requestAnimationFrame(loop); }
    function setMode(m){ animMode = m; prepareAnimation(); }

    // Expose to buttons
    window.playAnimation = playAnimation;
    window.stopAnimation = stopAnimation;
    window.restartAndPlay = restartAndPlay;
    window.setMode = setMode;

    // UI binding
    document.addEventListener('DOMContentLoaded', () => {
        const sel = document.getElementById('animMode');
        if(sel){ sel.addEventListener('change', e => setMode(e.target.value)); }
        const chk = document.getElementById('showAnchors');
        if(chk){
            showAnchors = chk.checked;
            chk.addEventListener('change', () => { showAnchors = chk.checked; });
        }
        const pairSel = document.getElementById('pairMode');
        if(pairSel){
            pairSel.addEventListener('change', () => { pairMode = pairSel.value; prepareAnimation(); });
        }
        const syncSel = document.getElementById('syncOverride');
        if(syncSel){ syncSel.addEventListener('change', () => { syncOverride = syncSel.value; prepareAnimation(); }); }
    });
</script>
{% endblock %}

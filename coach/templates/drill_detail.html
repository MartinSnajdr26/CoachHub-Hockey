{% extends "base.html" %}
{% block title %}{{ drill.name }}{% endblock %}

{% block content %}
{% if embed_mode %}
<style>
  html, body { margin:0; padding:0; height:100%; background:#fff; }
  .header-top, .header-bottom, footer { display:none !important; }
  main { margin:0; padding:0; }
  #board { display:block; width:100vw; height:100vh; }
</style>
{% else %}
<h1>{{ drill.name }}</h1>
<p><b>Kategorie:</b> {{ drill.category }}</p>
<p><b>Popis:</b> {{ drill.description }}</p>
<p><b>Doba:</b> {{ drill.duration }} min</p>
{% endif %}

<!-- Canvas -->
<canvas id="board" style="border:2px solid var(--brand-primary, #d4c76f); border-radius:8px; background:white;"></canvas>

{% if not embed_mode %}
<style>
  .viewer-toolbar{ display:flex; flex-wrap:wrap; align-items:center; gap:10px; background: var(--brand-primary, #d4c76f); padding:8px; border-radius:12px; margin-top:15px; }
  .viewer-toolbar .btn{ min-width:36px; height:36px; padding:4px 8px; border:1px solid var(--brand-secondary, #000); background:#fff; color: var(--brand-secondary, #000); border-radius:8px; cursor:pointer; display:inline-flex; align-items:center; justify-content:center; }
  .viewer-toolbar .btn:hover{ background: color-mix(in srgb, #fff 70%, var(--brand-primary, #d4c76f) 30%); }
  .viewer-toolbar .grp{ display:flex; align-items:center; gap:8px; }
  .viewer-toolbar label{ font-size:12px; display:flex; align-items:center; gap:6px; margin:0; }
  .viewer-toolbar select{ padding:4px 8px; border-radius:8px; border:1px solid var(--brand-secondary, #000); background:#fff; color: var(--brand-secondary, #000); }
  .viewer-toolbar input[type="checkbox"]{ width:16px; height:16px; }
  .viewer-toolbar .zoom{ display:flex; align-items:center; gap:6px; }
  .viewer-toolbar .zoom #zoomPct{ min-width:48px; text-align:center; }
  @media (max-width: 700px){ .viewer-toolbar{ gap:8px; } }
</style>
<div class="viewer-toolbar">
  <button type="button" class="btn" id="btnPlay" title="P≈ôehr√°t">‚ñ∂</button>
  <button type="button" class="btn" id="btnPause" title="Pauza">‚è∏</button>
  <button type="button" class="btn" id="btnStop" title="Stop">‚èπ</button>
  <div class="grp" style="margin-left:6px;">
    <label>Re≈æim:
      <select id="animMode">
        <option value="sequential" selected>Sekvence</option>
        <option value="grouped">Skupiny (mezi ikonami)</option>
      </select>
    </label>
    <label>P√°rov√°n√≠:
      <select id="pairMode">
        <option value="smart" selected>Chytr√©</option>
        <option value="order">Dle po≈ôad√≠ ikon</option>
        <option value="nearest">Dle nejbli≈æ≈°√≠ ikony</option>
      </select>
    </label>
    <label title="Zobrazit doƒçasn√© a trval√© kotvy" style="display:flex; align-items:center; gap:6px;">
      <input type="checkbox" id="showAnchors"> Kotvy
    </label>
  </div>
  <div class="zoom" style="margin-left:auto;">
    <span>Zoom:</span>
    <button type="button" class="btn" id="zoomOut" title="Zmen≈°it">‚àí</button>
    <span id="zoomPct">100%</span>
    <button type="button" class="btn" id="zoomIn" title="Zvƒõt≈°it">+</button>
    <button type="button" class="btn" id="zoomReset" title="Reset">‚ü≤</button>
    <input type="range" id="zoomRange" min="50" max="200" value="100" step="5" style="vertical-align:middle; width:160px;">
  </div>
</div>
{% endif %}

{% if is_coach %}
<form method="POST" action="{{ url_for('delete_drill', drill_id=drill.id) }}">
    <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
    <button type="submit" style="color: var(--tertiary, #c44747);">üóë Smazat cviƒçen√≠</button>
    
</form>
{% endif %}

<script nonce="{{ csp_nonce }}">
    const canvas = document.getElementById("board");
    const ctx = canvas.getContext("2d");
    const rink = new Image();
    rink.src = "/static/rink.png";
    const icons = []; // seznam ikon hr√°ƒç≈Ø z editoru
    const entityColors = new Map(); // eid -> color (od editoru), fallback podle role


    // Data z editoru ‚Äì robustn√≠ naƒçten√≠ i pro None/""/string
    const rawPathData = {{ drill.path_data | tojson | safe }}; // m≈Ø≈æe b√Ωt null nebo string JSON
    const rawImageData = {{ drill.image_data | tojson | safe }}; // base64 snapshot z editoru
    const EMBED = {{ 'true' if embed_mode else 'false' }};
    let drawData = [];
    if (Array.isArray(rawPathData)) {
        drawData = rawPathData;
    } else if (typeof rawPathData === 'string' && rawPathData.trim() !== '') {
        try { drawData = JSON.parse(rawPathData); } catch (_) { drawData = []; }
    }

    // Konfigurace animace
    const PLAYER_SPEED = 120; // px/s
    const PUCK_SPEED = 180;   // px/s
    let animMode = 'sequential'; // 'sequential' | 'grouped'
    let pairMode = 'smart';      // 'smart' | 'order' | 'nearest'
    let syncOverride = 'off'; // 'off' only (override select removed)
    let showAnchors = false;      // zobrazovat start/stop/p≈ôihr√°vkov√© kotvy (default vypnuto)

    // Intern√≠ stav
    let animationFrame;
    let lastTimestamp;
    let globalTime = 0; // glob√°ln√≠ ƒças animace v sekund√°ch
    let paused = false;
    let totalDuration = 0; // d√©lka cel√© animace
    const moves = [];    // {kind:'player'|'puck', points, length, start, duration, role, entityId?, lastOfEntity?}
    const statics = [];  // polo≈æky, kter√© se prostƒõ vykresl√≠
    const initialByEntity = new Map(); // entityId -> {x, y, role, color?}
    const finalByEntity = new Map();   // entityId -> {end, x, y, role}
    const passAnchors = [];            // {x, y, role, tStart, tEnd, tHide, entityId}
    const anchorsPermanent = [];       // trval√© kotvy: {x, y, role, t, tHide}

    // --- Debug helpers (off by default) ---
    let DEBUG = false;
    let DEBUG_GRID = false;
    try {
        const usp = new URLSearchParams(window.location.search);
        DEBUG = (usp.get('debug') === '1') || (localStorage.getItem('drillDebug') === '1');
    } catch(_) {}
    let debugPanelEl = null;
    let debugToolbarEl = null;
    let debugContentEl = null;
    function ensureDebugPanel(){
        if(!DEBUG) return;
        if(debugPanelEl) return;
        debugPanelEl = document.createElement('div');
        debugPanelEl.id = 'debugPanel';
        debugPanelEl.style.cssText = 'margin-top:10px; padding:8px; border:1px dashed #888; background:#fffff8; color:#333; font:12px/1.4 monospace;';
        // toolbar
        debugToolbarEl = document.createElement('div');
        debugToolbarEl.style.cssText = 'margin-bottom:6px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;';
        const btnDbg = document.createElement('button'); btnDbg.type='button'; btnDbg.textContent = DEBUG ? 'Debug: ON' : 'Debug: OFF';
        btnDbg.addEventListener('click', ()=>{ setDebug(!DEBUG); btnDbg.textContent = DEBUG ? 'Debug: ON' : 'Debug: OFF'; });
        const btnGrid = document.createElement('button'); btnGrid.type='button'; btnGrid.textContent = DEBUG_GRID ? 'Grid: ON' : 'Grid: OFF';
        btnGrid.addEventListener('click', ()=>{ DEBUG_GRID = !DEBUG_GRID; btnGrid.textContent = DEBUG_GRID ? 'Grid: ON' : 'Grid: OFF'; drawBackground(); renderFrame(0); });
        debugToolbarEl.appendChild(btnDbg);
        debugToolbarEl.appendChild(btnGrid);
        // content
        debugContentEl = document.createElement('pre');
        debugContentEl.style.cssText = 'margin:0; white-space:pre-wrap;';
        // assemble
        debugPanelEl.appendChild(debugToolbarEl);
        debugPanelEl.appendChild(debugContentEl);
        canvas.parentElement.appendChild(debugPanelEl);
    }
    function setDebug(val){ DEBUG = !!val; try { localStorage.setItem('drillDebug', DEBUG ? '1':'0'); } catch(_) {}; if(DEBUG){ ensureDebugPanel(); updateDebug(); drawBackground(); renderFrame(0);} else { if(debugPanelEl){ debugPanelEl.remove(); debugPanelEl=null; debugToolbarEl=null; debugContentEl=null; } drawBackground(); renderFrame(0);} }
    function updateDebug(extra){ if(!DEBUG) return; ensureDebugPanel(); try { if(debugContentEl) debugContentEl.textContent = (extra || buildDebugInfo()); } catch(_) {}
    }
    function buildDebugInfo(){
        const info = [];
        const meta = (Array.isArray(drawData) && drawData[0] && drawData[0].tool === 'meta') ? drawData[0] : null;
        const mW = meta?.canvas_w, mH = meta?.canvas_h;
        const bW = origW || mW || 0;
        const bH = origH || mH || 0;
        const f = fitRect(bW||canvas.width, bH||canvas.height, canvas.width, canvas.height);
        info.push(`CANVAS ${canvas.width}x${canvas.height}`);
        const imgW = (savedImg && savedImg.width) ? savedImg.width : '?';
        const imgH = (savedImg && savedImg.height) ? savedImg.height : '?';
        info.push(`BASE (editor) ${bW||'?'}x${bH||'?'} | META ${mW||'?'}x${mH||'?'} | IMG ${imgW}x${imgH} | SRC ${HAVE_META_SIZE?'meta':(imgW!=='?'?'img':'none')}`);
        info.push(`FIT k=${f.k.toFixed(4)} off=(${f.x},${f.y}) size=${f.w}x${f.h}`);
        info.push(`icons=${icons.length}, statics=${statics.length}, moves=${moves.length}`);
        return info.join('\n');
    }

    // --- Zoom state ---
    let zoom = 1.0; const MIN_ZOOM = 0.5, MAX_ZOOM = 2.0; let manualZoom = false;
    function updateZoomLabel(){
        try {
            const el = document.getElementById('zoomPct'); if(el) el.textContent = Math.round(zoom*100) + '%';
            const rng = document.getElementById('zoomRange'); if(rng){ const v = Math.round(zoom*100); if(parseInt(rng.value,10)!==v) rng.value = v; }
        } catch(_){ }
    }

    // Rozhodnut√≠ velikosti canvasu: preferuj ulo≈æen√Ω snapshot z editoru
    let sizeDecided = false;
    const savedImg = new Image();
    let origW = null, origH = null; // p≈Øvodn√≠ rozmƒõry pl√°tna v editoru
    let HAVE_META_SIZE = false;     // preferuj meta z path_data p≈ôed rozmƒõry snapshotu

    // 1) Pokus se naƒç√≠st velikost z META hned teƒè (je synchronn√≠)
    try {
        if (Array.isArray(drawData) && drawData.length && drawData[0] && drawData[0].tool === 'meta'){
            const mw = parseInt(drawData[0].canvas_w, 10);
            const mh = parseInt(drawData[0].canvas_h, 10);
            if(!isNaN(mw) && mw > 0){ origW = mw; HAVE_META_SIZE = true; }
            if(!isNaN(mh) && mh > 0){ origH = mh; HAVE_META_SIZE = true; }
        }
    } catch(_) {}

    // 2) Jako fallback pou≈æij rozmƒõr snapshotu (asynchronn√≠)
    if (typeof rawImageData === 'string' && rawImageData.startsWith('data:image')) {
        savedImg.onload = () => {
            if(!HAVE_META_SIZE && (origW == null || origH == null)){
                origW = savedImg.width; origH = savedImg.height;
            }
        };
        savedImg.src = rawImageData;
    }
    function containerWidth(){ try { return Math.max(320, Math.floor(canvas.parentElement.clientWidth)); } catch(_) { return 1000; } }
    function isMobile(){
        try { return window.matchMedia && window.matchMedia('(max-width: 768px)').matches; } catch(_) { return false; }
    }
    function baseCanvasSize(){
        let w, h;
        if(EMBED){
            w = Math.max(1, Math.round(window.innerWidth || document.documentElement.clientWidth || 800));
            h = Math.max(1, Math.round(window.innerHeight || document.documentElement.clientHeight || 600));
        } else if(!isMobile() && origW && origH){
            w = Math.max(1, Math.round(origW));
            h = Math.max(1, Math.round(origH));
        } else {
            w = containerWidth();
            h = (w / rink.width) * rink.height;
        }
        return {w, h};
    }

    function applyCanvasSize(){
        const base = baseCanvasSize();
        const targetW = Math.max(1, Math.round(base.w * zoom));
        const targetH = Math.max(1, Math.round(base.h * zoom));
        canvas.width = targetW;
        canvas.height = targetH;
        drawBackground();
        prepareAnimation();
        renderFrame(0);
        updateZoomLabel();
    }

    rink.onload = () => {
        if (!sizeDecided) {
            sizeDecided = true;
            applyCanvasSize();
        }
    };

    function decideSize(w, h){
        if (sizeDecided) return;
        sizeDecided = true;
        canvas.width = Math.max(1, Math.round(w));
        canvas.height = Math.max(1, Math.round(h));
        drawBackground();
        prepareAnimation();
        renderFrame(0);
    }

    // Pokud je v path_data meta s rozmƒõry editoru, pou≈æij ji jako zdrojov√© mƒõ≈ô√≠tko
    try {
        if (Array.isArray(drawData) && drawData.length && drawData[0] && drawData[0].tool === 'meta'){
            const mw = parseInt(drawData[0].canvas_w, 10);
            const mh = parseInt(drawData[0].canvas_h, 10);
            if(!isNaN(mw) && mw > 0){ origW = mw; HAVE_META_SIZE = true; }
            if(!isNaN(mh) && mh > 0){ origH = mh; HAVE_META_SIZE = true; }
        }
    } catch(_) {}

    // Reakce na zmƒõnu velikosti okna ‚Äì p≈ôepoƒç√≠t√° pl√°tno a znovu vykresl√≠
    let resizeTimer;
    window.addEventListener('resize', function(){
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(function(){
            if(!manualZoom){ zoom = 1.0; }
            applyCanvasSize();
        }, 150);
    });

    function fitRect(baseW, baseH, outW, outH){
        const k = Math.min(outW / Math.max(1, baseW), outH / Math.max(1, baseH));
        const w = Math.round(baseW * k);
        const h = Math.round(baseH * k);
        const x = Math.round((outW - w) / 2);
        const y = Math.round((outH - h) / 2);
        return {k, x, y, w, h};
    }

    function drawBackground() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // Draw rink with the same fit used for overlay to keep perfect alignment
        const baseW = origW || rink.width || canvas.width;
        const baseH = origH || rink.height || canvas.height;
        const f = fitRect(baseW, baseH, canvas.width, canvas.height);
        try { ctx.drawImage(rink, f.x, f.y, f.w, f.h); } catch(_) {}
        if(DEBUG){
            // Outline fitted area
            ctx.save();
            ctx.strokeStyle = 'rgba(200,0,0,0.8)';
            ctx.lineWidth = 2;
            ctx.setLineDash([6,4]);
            ctx.strokeRect(f.x+1, f.y+1, Math.max(0,f.w-2), Math.max(0,f.h-2));
            if(DEBUG_GRID){
                ctx.setLineDash([]);
                ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                for(let gx=f.x; gx<=f.x+f.w; gx+=Math.max(20, Math.round(f.w/20))){ ctx.beginPath(); ctx.moveTo(gx, f.y); ctx.lineTo(gx, f.y+f.h); ctx.stroke(); }
                for(let gy=f.y; gy<=f.y+f.h; gy+=Math.max(20, Math.round(f.h/20))){ ctx.beginPath(); ctx.moveTo(f.x, gy); ctx.lineTo(f.x+f.w, gy); ctx.stroke(); }
            }
            ctx.restore();
            updateDebug();
        }
    }

    function distance(a, b){ const dx=b.x-a.x, dy=b.y-a.y; return Math.hypot(dx,dy); }

    function annotateCumulative(points){
        let acc = 0; const out = [{...points[0], s:0}];
        for(let i=1;i<points.length;i++){ acc += distance(points[i-1], points[i]); out.push({...points[i], s:acc}); }
        return {points: out, length: acc};
    }

    // Nav√°≈æe nejbli≈æ≈°√≠ p≈ôedchoz√≠ ikonu hr√°ƒçe jako roli k n√°sleduj√≠c√≠mu pathu
    function prepareAnimation(){
        moves.length = 0; statics.length = 0; finalByEntity.clear(); passAnchors.length = 0; anchorsPermanent.length = 0;
        icons.length = 0; // reset glob√°ln√≠ kolekce ikon
        let pendingRole = null;
        let currentEntityId = 0; // identifik√°tor hr√°ƒçe dle posledn√≠ ikony
        const entities = new Map(); // eid -> {role, x, y}

        // ≈°k√°lov√°n√≠ sou≈ôadnic z editoru na aktu√°ln√≠ pl√°tno
        const baseW = origW || canvas.width;
        const baseH = origH || canvas.height;
        const fit = fitRect(baseW, baseH, canvas.width, canvas.height);
        const k = fit.k, offX = fit.x, offY = fit.y;

        function nearestIconForPath(startX, startY, maxIdx){
            let best = null; let bestDist = Infinity;
            const radius = Math.max(20, canvas.width * 0.012);
            for(const ic of icons){
                if(ic.idx > maxIdx) continue;
                const d = Math.hypot(ic.x - startX, ic.y - startY);
                if(d < radius && d < bestDist){ best = ic; bestDist = d; }
            }
            if(!best){
                // fallback na absolutnƒõ nejbli≈æ≈°√≠ p≈ôedchoz√≠ ikonu
                for(const ic of icons){
                    if(ic.idx > maxIdx) continue;
                    const d = Math.hypot(ic.x - startX, ic.y - startY);
                    if(d < bestDist){ best = ic; bestDist = d; }
                }
            }
            return best; // m≈Ø≈æe b√Ωt null
        }

        function nearestEntityCurrent(startX, startY){
            let best = null; let bestDist = Infinity;
            for(const [eid, ent] of entities.entries()){
                const d = Math.hypot(ent.x - startX, ent.y - startY);
                if(d < bestDist){ best = {eid, role: ent.role, x: ent.x, y: ent.y}; bestDist = d; }
            }
            return best;
        }

        function assignEntityForPath(points, idx, pendingRole, currentEntityId, lastPass){
            // returns {eid, role}
            // priority (smart): last pass recipient near start -> nearest icon -> order
            if(pairMode === 'order'){
                return { eid: (currentEntityId || null), role: pendingRole };
            }
            const start = points[0];
            if(pairMode === 'smart'){
                if(lastPass && lastPass.eid != null){
                    const ent = entities.get(lastPass.eid);
                    if(ent){
                        const d = Math.hypot(start.x - ent.x, start.y - ent.y);
                        const r = Math.max(20, canvas.width * 0.012);
                        if(d < r) return { eid: lastPass.eid, role: ent.role };
                    }
                }
            }
            // prefer aktu√°ln√≠ pozici figurky (≈°achovnicov√° logika)
            const nEnt = nearestEntityCurrent(start.x, start.y);
            if(nEnt) return { eid: nEnt.eid, role: nEnt.role };
            // fallback: pozice nejbli≈æ≈°√≠ ikony
            const nearest = nearestIconForPath(start.x, start.y, idx);
            if(nearest) return { eid: nearest.eid, role: nearest.role };
            // fallback
            return { eid: (currentEntityId || null), role: pendingRole };
        }

        if (animMode === 'sequential') {
            let currentTime = 0; // akumuluje ƒças tak, jak jste kreslil
            let lastPass = null;  // {eid, role, x, y}
            let syncAfterPass = null; // {start, maxDur, remaining}
            // Jednoduch√Ω stav pr√°vƒõ otev≈ôen√© synchronn√≠ skupiny ‚Äì aby se dal≈°√≠ tahy pl√°novaly a≈æ po n√≠
            let currentGroup = null; // {id, start, maxEnd}

            function iconHasUpcomingMove(fromIndex){
                for(let k=fromIndex+1;k<drawData.length;k++){
                    const it = drawData[k];
                    if(it.tool === 'player_icon') return false;
                    if((it.tool === 'player_move' || it.tool === 'player_move_puck') && it.path) return true;
                }
                return false;
            }
            icons.length = 0;

            for(let idx=0; idx<drawData.length; idx++){
                const item = drawData[idx];
                if(item.tool === 'player_icon'){
                    pendingRole = item.role || null;
                    currentEntityId += 1;
                    const ix = offX + (item.x||0)*k, iy = offY + (item.y||0)*k;
                    const col = (item.color && typeof item.color === 'string' && item.color) || (pendingRole==='D' ? 'red' : (pendingRole==='F' ? 'blue' : 'black'));
                    initialByEntity.set(currentEntityId, {x: ix, y: iy, role: pendingRole, color: col});
                    entities.set(currentEntityId, {x: ix, y: iy, role: pendingRole});
                    icons.push({eid: currentEntityId, role: pendingRole, x: ix, y: iy, idx});
                    entityColors.set(currentEntityId, col);
                } else if(item.tool === 'puck_static'){
                    statics.push({tool:item.tool, x: offX + (item.x||0)*k, y: offY + (item.y||0)*k});
                } else if(item.tool === 'cone' || item.tool === 'triangle' || item.tool === 'pucks_cluster'){
                    statics.push({tool:item.tool, x: offX + (item.x||0)*k, y: offY + (item.y||0)*k});
                } else if((item.tool === 'player_move' || item.tool === 'player_move_puck') && item.path){
                    const pts = item.path.map(p=>({x: offX + (p[0]||0)*k, y: offY + (p[1]||0)*k}));
                    if(pts.length < 2) continue;
                    const {points, length} = annotateCumulative(pts);
                    const duration = Math.max(0.001, length / PLAYER_SPEED);
                    const assigned = assignEntityForPath(points, idx, pendingRole, currentEntityId, lastPass);
                    const withPuck = (item.tool === 'player_move_puck');
                    let startTime = syncAfterPass ? syncAfterPass.start : currentTime;
                    const sg = parseInt(item.sync_group||0, 10) || 0;
                    // Spr√°va pr√°vƒõ otev≈ôen√© synchronn√≠ skupiny
                    if(sg>0){
                        if(!currentGroup){
                            // otev≈ôi novou skupinu v aktu√°ln√≠m ƒçase
                            currentGroup = { id: sg, start: startTime, maxEnd: startTime };
                        } else if(currentGroup.id !== sg){
                            // uzav≈ôi p≈ôedchoz√≠ skupinu, posu≈à ƒças a zaƒçni novou
                            currentTime = Math.max(currentTime, currentGroup.maxEnd);
                            startTime = currentTime;
                            currentGroup = { id: sg, start: startTime, maxEnd: startTime };
                        } else {
                            // pokraƒçuj v r√°mci stejn√© skupiny
                            startTime = currentGroup.start;
                        }
                    } else if(currentGroup){
                        // p≈ôi p≈ôechodu ze skupiny na neseskupen√© ‚Äì uzav≈ôi skupinu a posu≈à ƒças
                        currentTime = Math.max(currentTime, currentGroup.maxEnd);
                        startTime = currentTime;
                        currentGroup = null;
                    }
                    const moveObj = {kind:'player', role: assigned.role, points, length, start: startTime, duration, entityId: assigned.eid, withPuck, sync_group: sg};
                    moves.push(moveObj);
                    // aktualizuj maxim√°ln√≠ konec pro pr√°vƒõ otev≈ôenou skupinu
                    if(sg>0 && currentGroup){
                        const end = startTime + duration;
                        if(end > currentGroup.maxEnd) currentGroup.maxEnd = end;
                    }
                    // posu≈à aktu√°ln√≠ pozici figurky na konec tahu
                    if(assigned.eid != null){ const endPt = points[points.length-1]; const ent = entities.get(assigned.eid); if(ent){ ent.x = endPt.x; ent.y = endPt.y; } }
                    if(syncAfterPass){
                        syncAfterPass.maxDur = Math.max(syncAfterPass.maxDur, duration);
                        syncAfterPass.remaining -= 1;
                        if(syncAfterPass.remaining <= 0){
                            currentTime = Math.max(currentTime, syncAfterPass.start + syncAfterPass.maxDur);
                            syncAfterPass = null;
                        }
                    } else {
                        // mimo skupinu posouvej ƒças bƒõ≈ænƒõ
                        if(!(sg>0)) currentTime += duration;
                    }
                } else if(item.tool === 'puck' && item.path){
                    const pts = item.path.map(p=>({x: offX + (p[0]||0)*k, y: offY + (p[1]||0)*k}));
                    if(pts.length < 2) continue;
                    const {points, length} = annotateCumulative(pts);
                    const duration = Math.max(0.001, length / PUCK_SPEED);
                    // pokud je zrovna otev≈ôen√° skupina hr√°ƒç≈Ø, uzav≈ôi ji p≈ôed pl√°nov√°n√≠m p≈ôihr√°vky/st≈ôely
                    if(currentGroup){
                        currentTime = Math.max(currentTime, currentGroup.maxEnd);
                        currentGroup = null;
                    }
                    // nastav p≈ô√≠jemce pro chytr√© p√°rov√°n√≠ dal≈°√≠ho tahu (podle c√≠le p≈ôihr√°vky)
                    lastPass = null;
                    if(pairMode !== 'order'){
                        const endPt = points[points.length-1];
                        // zkus naj√≠t p≈ô√≠jemce podle aktu√°ln√≠ch pozic figur
                        const rec = nearestEntityCurrent(endPt.x, endPt.y) || nearestIconForPath(endPt.x, endPt.y, idx);
                        if(rec) lastPass = { eid: rec.eid, role: rec.role, x: endPt.x, y: endPt.y };
                    }
                    moves.push({kind:'puck', role:null, points, length, start: currentTime, duration});
                    // per-pass sync: podle override v UI nebo flagu z editoru
                    let syncNextCount = 0;
                    if(syncOverride === 'two') syncNextCount = 2;
                    else if(syncOverride === 'respect') syncNextCount = parseInt(item.sync_next||0, 10) || 0;
                    else syncNextCount = 0;
                    if(syncNextCount > 0){
                        const passEnd = currentTime + duration;
                        currentTime = passEnd; // posu≈à ƒças na konec p≈ôihr√°vky
                        syncAfterPass = { start: passEnd, maxDur: 0, remaining: syncNextCount };
                    } else {
                        currentTime += duration;
                    }
                }
            }
            // Uzav≈ôi p≈ô√≠padnou posledn√≠ skupinu
            if(currentGroup){
                currentTime = Math.max(currentTime, currentGroup.maxEnd);
                currentGroup = null;
            }
            totalDuration = currentTime;
        } else {
            // grouped: v≈°e od ikony po dal≈°√≠ ikonu bƒõ≈æ√≠ souƒçasnƒõ; skupiny jdou za sebou
            let groupStart = 0;
            let groupMoves = [];
            let groupIcon = null; // posledn√≠ ikona, kter√° skupinu zah√°jila
            let pendingSync = null; // {start, remaining, maxDur}
            const groupStates = new Map(); // sync_group -> {start}

            function flushGroup(){
                if(groupMoves.length === 0){
                    // nic k animaci ‚Äì ikonu nech vykreslit v ƒç√°sti hr√°ƒç≈Ø (poƒç√°teƒçn√≠ stav)
                    return; 
                }
                // nastav start podle p≈ô√≠padn√Ωch override a spoƒç√≠tej konec cel√© skupiny
                let maxEnd = groupStart;
                for(const m of groupMoves){
                    const s = (m.startOverride != null) ? m.startOverride : groupStart;
                    m.start = s; moves.push(m);
                    const end = s + m.duration; if(end > maxEnd) maxEnd = end;
                }
                groupStart = maxEnd; // dal≈°√≠ skupina zaƒçne po skonƒçen√≠ t√©to (vƒçetnƒõ paraleln√≠ch override)
                groupMoves = []; groupIcon = null;
                pendingSync = null;
            }

            for(let idx=0; idx<drawData.length; idx++){
                const item = drawData[idx];
                if(item.tool === 'player_icon'){
                    flushGroup();
                    pendingRole = item.role || null;
                    currentEntityId += 1;
                    const ix = offX + (item.x||0)*k, iy = offY + (item.y||0)*k;
                    initialByEntity.set(currentEntityId, {x: ix, y: iy, role: pendingRole});
                    entities.set(currentEntityId, {x: ix, y: iy, role: pendingRole});
                    icons.push({eid: currentEntityId, role: pendingRole, x: ix, y: iy, idx});
                    groupIcon = item;
                } else if(item.tool === 'puck_static'){
                    // statick√° souƒç√°st ‚Äì nez√°visl√° na skupin√°ch
                    statics.push({tool:item.tool, x: offX + (item.x||0)*k, y: offY + (item.y||0)*k});
                } else if(item.tool === 'cone' || item.tool === 'triangle' || item.tool === 'pucks_cluster'){
                    statics.push({tool:item.tool, x: offX + (item.x||0)*k, y: offY + (item.y||0)*k});
                } else if((item.tool === 'player_move' || item.tool === 'player_move_puck') && item.path){
                    const pts = item.path.map(p=>({x: offX + (p[0]||0)*k, y: offY + (p[1]||0)*k}));
                    if(pts.length < 2) continue;
                    const {points, length} = annotateCumulative(pts);
                    const duration = Math.max(0.001, length / PLAYER_SPEED);
                    const assigned = assignEntityForPath(points, idx, pendingRole, currentEntityId, null);
                    const withPuck = (item.tool === 'player_move_puck');
                    let startOverride = null;
                    const sg = parseInt(item.sync_group||0, 10) || 0;
                    if(sg>0){ if(!groupStates.has(sg)) groupStates.set(sg, {start: groupStart}); startOverride = groupStates.get(sg).start; }
                    const moveObj = {kind:'player', role: assigned.role, points, length, duration, entityId: assigned.eid, withPuck};
                    if(startOverride!=null) moveObj.startOverride = startOverride;
                    if(pendingSync){
                        moveObj.startOverride = pendingSync.start;
                        pendingSync.maxDur = Math.max(pendingSync.maxDur, duration);
                        pendingSync.remaining -= 1;
                        if(pendingSync.remaining <= 0){
                            // pendingSync resolved; groupStart will be adjusted in flushGroup via maxEnd
                            pendingSync = null;
                        }
                    }
                    groupMoves.push(moveObj);
                } else if(item.tool === 'puck' && item.path){
                    const pts = item.path.map(p=>({x: offX + (p[0]||0)*k, y: offY + (p[1]||0)*k}));
                    if(pts.length < 2) continue;
                    const {points, length} = annotateCumulative(pts);
                    const duration = Math.max(0.001, length / PUCK_SPEED);
                    const passObj = {kind:'puck', role:null, points, length, duration};
                    groupMoves.push(passObj);
                    let syncNextCount = 0;
                    if(syncOverride === 'two') syncNextCount = 2;
                    else if(syncOverride === 'respect') syncNextCount = parseInt(item.sync_next||0, 10) || 0;
                    else syncNextCount = 0;
                    if(syncNextCount > 0){
                        const passEnd = groupStart + duration; // pass start is groupStart in this group
                        // nastav pending sync pro dal≈°√≠ N hr√°ƒçsk√Ωch tah≈Ø
                        pendingSync = { start: passEnd, remaining: syncNextCount, maxDur: 0 };
                    }
                }
            }
            flushGroup();
            totalDuration = groupStart;
        }
        // Po sestaven√≠ tah≈Ø spoƒç√≠tej fin√°ln√≠ stav hr√°ƒçe (konec posledn√≠ho tahu)
        const byEntity = new Map();
        for(const m of moves){
            if(m.kind !== 'player' || m.entityId == null) continue;
            const end = (m.start ?? 0) + m.duration;
            const lastPt = m.points[m.points.length - 1];
            const cur = byEntity.get(m.entityId);
            if(!cur || end > cur.end){
                byEntity.set(m.entityId, {end, x: lastPt.x, y: lastPt.y, role: m.role});
            }
        }
        for(const [eid, info] of byEntity.entries()) finalByEntity.set(eid, info);
        // P≈ôidej doƒçasn√© kotvy pro p≈ôihr√°vky: bƒõhem letu puku nech ikonu hr√°ƒçe na zaƒç√°tku p≈ôihr√°vky
        // Odvod√≠me roli a pozici z nejbli≈æ≈°√≠ho p≈ôedchoz√≠ho konce pohybu hr√°ƒçe pobl√≠≈æ startu p≈ôihr√°vky
        const playerEnds = [];
        const playerMovesByEntity = new Map(); // entityId -> [{start, duration}]
        for(const pm of moves){
            if(pm.kind !== 'player') continue;
            const endT = pm.start + pm.duration;
            const endPt = pm.points[pm.points.length - 1];
            playerEnds.push({t:endT, x:endPt.x, y:endPt.y, role: pm.role || 'F', entityId: pm.entityId});
            if(pm.entityId != null){
                if(!playerMovesByEntity.has(pm.entityId)) playerMovesByEntity.set(pm.entityId, []);
                playerMovesByEntity.get(pm.entityId).push({start: pm.start, duration: pm.duration});
            }
        }
        // se≈ôaƒè starty u hr√°ƒç≈Ø
        for(const arr of playerMovesByEntity.values()) arr.sort((a,b)=>a.start-b.start);

        // P≈ôidej koncov√© kotvy po ka≈æd√©m hr√°ƒçovƒõ tahu ‚Äì z≈Østanou do zaƒç√°tku dal≈°√≠ho pohybu stejn√©ho hr√°ƒçe
        for(const m of moves){
            if(m.kind !== 'player' || m.entityId == null) continue;
            const info = finalByEntity.get(m.entityId);
            const end = (m.start ?? 0) + m.duration;
            m.lastOfEntity = info && Math.abs(end - info.end) < 1e-6;
            const endPt = m.points[m.points.length - 1];
            const seq = (m.entityId != null) ? (playerMovesByEntity.get(m.entityId) || []) : [];
            let nextStart = Infinity;
            for(const mv of seq){ if(mv.start > (m.start ?? 0) + 1e-6){ nextStart = mv.start; break; } }
            anchorsPermanent.push({x: endPt.x, y: endPt.y, role: m.role || 'F', t: end, tHide: nextStart, color: entityColors.get(m.entityId) || null});
        }

        // Po sestaven√≠ tah≈Ø p≈ôidej startovn√≠ kotvy s tHide = zaƒç√°tek prvn√≠ho pohybu hr√°ƒçe (pokud existuje)
        for(const [eid, init] of initialByEntity.entries()){
            let tHide = Infinity;
            const seq = playerMovesByEntity.get(eid) || [];
            if(seq.length){ tHide = seq[0].start; }
            anchorsPermanent.push({x: init.x, y: init.y, role: init.role || 'F', t: 0, tHide, color: initialByEntity.get(eid)?.color || null});
        }
        function nearestEndBefore(tStart, x0, y0){
            let best = null; let bestDt = Infinity; let bestDist = Infinity;
            for(const e of playerEnds){
                if(e.t > tStart + 1e-6) continue;
                const dist = Math.hypot(e.x - x0, e.y - y0);
                const dt = tStart - e.t;
                const radius = Math.max(15, canvas.width * 0.01);
                if(dist < radius && (dt < bestDt || (Math.abs(dt-bestDt)<1e-6 && dist < bestDist))){ best = e; bestDt = dt; bestDist = dist; }
            }
            return best;
        }

        function activePlayerAt(time){
            let found = null;
            for(const mv of moves){
                if(mv.kind !== 'player') continue;
                if(time >= mv.start && time < mv.start + mv.duration){
                    if(!found || mv.start > found.start) found = mv;
                }
            }
            return found;
        }
        let lastKnownRole = null;
        for(const m of moves){
            if(m.kind === 'player') lastKnownRole = m.role || lastKnownRole;
            if(m.kind !== 'puck' || m.entityId != null) continue; // samostatn√° p≈ôihr√°vka
            const tStart = m.start, tEnd = m.start + m.duration;
            const startPt = m.points[0];
            const active = activePlayerAt(tStart);
            const match = active ? { role: active.role || 'F', entityId: active.entityId } : nearestEndBefore(tStart, startPt.x, startPt.y);
            const role = (match && match.role) || lastKnownRole || 'F';
            let tHide = Infinity;
            if(match && match.entityId != null){
                const seq = playerMovesByEntity.get(match.entityId) || [];
                for(const mv of seq){
                    if(mv.start + 1e-6 >= tEnd){ tHide = mv.start; break; }
                }
            }
            passAnchors.push({x: startPt.x, y: startPt.y, role, tStart, tEnd, tHide, entityId: match ? match.entityId : null, color: (match && match.entityId!=null) ? (entityColors.get(match.entityId) || null) : null});
        }
        if(DEBUG){ updateDebug(); }
    }

    function drawStatics(k){
        // clamp helper
        const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
        const puckR = clamp(6 * k, 3, 10);
        const clusterR = clamp(5 * k, 2.5, 9);
        const clusterOff = 12 * k;
        const coneW = 10 * k, coneH = 20 * k;
        const tri = 15 * k;
        for(const it of statics){
            if(it.tool === 'puck_static'){
                ctx.beginPath(); ctx.arc(it.x, it.y, puckR, 0, 2*Math.PI); ctx.fillStyle = 'black'; ctx.fill();
            } else if(it.tool === 'cone'){
                ctx.fillStyle = 'orange'; ctx.beginPath(); ctx.moveTo(it.x, it.y); ctx.lineTo(it.x-coneW, it.y+coneH); ctx.lineTo(it.x+coneW, it.y+coneH); ctx.closePath(); ctx.fill();
            } else if(it.tool === 'triangle'){
                ctx.fillStyle = 'purple'; ctx.beginPath(); ctx.moveTo(it.x, it.y-tri); ctx.lineTo(it.x-tri, it.y+tri); ctx.lineTo(it.x+tri, it.y+tri); ctx.closePath(); ctx.fill();
            } else if(it.tool === 'pucks_cluster'){
                ctx.fillStyle = 'black';
                for(let i=-1;i<=1;i++) for(let j=-1;j<=1;j++){ if(i||j){ ctx.beginPath(); ctx.arc(it.x+i*clusterOff, it.y+j*clusterOff, clusterR, 0, 2*Math.PI); ctx.fill(); } }
                ctx.beginPath(); ctx.arc(it.x, it.y, puckR, 0, 2*Math.PI); ctx.fill();
            }
        }
    }

    // Z√°mƒõrnƒõ nerysujeme podkladov√© trasy ‚Äì v animaci se zobrazuj√≠ jen ikony hr√°ƒçe a puk

    function drawRoleCircle(role, x, y, alpha=1, k=1, colorOverride=null){
        const color = colorOverride || (role === 'F' ? 'blue' : role === 'D' ? 'red' : 'black');
        const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
        const r = clamp(16 * k, 10, 28); // bez textu uvnit≈ô, ƒçist√° barva dle role
        ctx.save();
        ctx.globalAlpha = Math.max(0, Math.min(1, alpha));
        ctx.beginPath(); ctx.arc(x, y, r, 0, 2*Math.PI); ctx.fillStyle = color; ctx.fill();
        ctx.restore();
    }

    function positionAt(m, elapsed){
        // elapsed v sekund√°ch -> ujet√° vzd√°lenost
        const dist = Math.min(elapsed / m.duration * m.length, m.length);
        // najdi segment
        let i = 1; while(i < m.points.length && m.points[i].s < dist) i++;
        if(i >= m.points.length) return m.points[m.points.length-1];
        const a = m.points[i-1], b = m.points[i];
        const segLen = b.s - a.s || 1;
        const t = (dist - a.s) / segLen;
        return {x: a.x + (b.x - a.x)*t, y: a.y + (b.y - a.y)*t};
    }

    function renderFrame(dt){
        globalTime += dt;
        drawBackground();
        // derive current scale k for size scaling
        const baseWk = origW || canvas.width;
        const baseHk = origH || canvas.height;
        const fitNow = fitRect(baseWk, baseHk, canvas.width, canvas.height);
        const kNow = fitNow.k || 1;
        drawStatics(kNow);
        // bez podkladov√Ωch ƒçar ‚Äì pouze ikony a puk
        // Vykresli pohybliv√© objekty ‚Äì hr√°ƒç je v≈ædy viditeln√Ω: p≈ôed prvn√≠m tahem na startu,
        // bƒõhem tahu se h√Ωbe, po konci z≈Øst√°v√° na konci posledn√≠ho dokonƒçen√©ho tahu
        // Pou≈æij jen entity, kter√© maj√≠ v editoru ikonu hr√°ƒçe
        const allowedEntities = new Set(icons.map(ic => ic.eid));
        const drawnNow = [];

        for (const eid of allowedEntities) {
            // 1) Aktivn√≠ tah (pokud pr√°vƒõ bƒõ≈æ√≠)
            let active = null;
            for (const m of moves) {
                if (m.kind !== 'player' || m.entityId !== eid) continue;
                if (globalTime >= m.start && globalTime < m.start + m.duration) {
                    if (!active || m.start > active.start) active = m;
                }
            }
            if (active) {
                const t = globalTime - active.start;
                const pos = positionAt(active, t);
                drawRoleCircle(active.role || (initialByEntity.get(eid)?.role) || 'F', pos.x, pos.y, 1, kNow, entityColors.get(active.entityId) || (initialByEntity.get(eid)?.color) || null);
                drawnNow.push({x: pos.x, y: pos.y});
                continue;
            }

            // 1b) Nen√≠ aktivn√≠ ‚Äì posledn√≠ dokonƒçen√Ω tah do aktu√°ln√≠ho ƒçasu
            let latest = null;
            for (const m of moves) {
                if (m.kind !== 'player' || m.entityId !== eid) continue;
                const end = m.start + m.duration;
                if (globalTime + 1e-6 >= end) {
                    if (!latest || end > (latest.start + latest.duration)) latest = m;
                }
            }
            if (latest) {
                const lastPt = latest.points[latest.points.length - 1];
                drawRoleCircle(latest.role || (initialByEntity.get(eid)?.role) || 'F', lastPt.x, lastPt.y, 1, kNow, entityColors.get(latest.entityId) || (initialByEntity.get(eid)?.color) || null);
                drawnNow.push({x: lastPt.x, y: lastPt.y});
                continue;
            }

            // 1c) P≈ôed prvn√≠m tahem ‚Äì poƒç√°teƒçn√≠ ikona
            const init = initialByEntity.get(eid);
            if (init) {
                drawRoleCircle(init.role || 'F', init.x, init.y, 1, kNow, (initialByEntity.get(eid)?.color) || null);
                drawnNow.push({x: init.x, y: init.y});
            }
        }

        // 2) Puky: pro j√≠zdu s pukem jsou ‚Äûp≈ôilepen√©‚Äú k hr√°ƒçi (stejn√° pozice); samostatn√© puky kresli z path
        // Puk s hr√°ƒçem
        for(const m of moves){
            if(m.kind !== 'player' || !m.withPuck) continue;
            if(globalTime < m.start || globalTime >= m.start + m.duration) continue;
            const t = globalTime - m.start;
            const pos = positionAt(m, t);
            ctx.beginPath(); ctx.arc(pos.x, pos.y, Math.max(3, Math.min(10, 6*kNow)), 0, 2*Math.PI); ctx.fillStyle = 'black'; ctx.fill();
        }
        // samostatn√© (nep≈ôi≈ôazen√©) puky
        for(const m of moves){
            if(m.kind !== 'puck' || m.entityId != null) continue; // samostatn√© puky (p≈ôihr√°vky/st≈ôely)
            if(globalTime < m.start || globalTime >= m.start + m.duration) continue;
            const t = globalTime - m.start;
            const pos = positionAt(m, t);
            ctx.beginPath(); ctx.arc(pos.x, pos.y, Math.max(3, Math.min(10, 6*kNow)), 0, 2*Math.PI); ctx.fillStyle = 'black'; ctx.fill();
        }
        if(showAnchors){
            // 3) Ikona hr√°ƒçe na zaƒç√°tku p≈ôihr√°vky: zobraz od zaƒç√°tku do zaƒç√°tku dal≈°√≠ho pohybu stejn√©ho hr√°ƒçe (pokud existuje)
            for(const a of passAnchors){
                if(globalTime + 1e-6 >= a.tStart && globalTime < a.tHide - 1e-6){
                    // vynech kotvu, pokud u≈æ je nakreslen√° ikona t√©mƒõ≈ô na stejn√©m m√≠stƒõ
                    let near = false;
                    for(const p of drawnNow){ if(Math.hypot(p.x - a.x, p.y - a.y) < 14){ near = true; break; } }
                    if(!near) drawRoleCircle(a.role || 'F', a.x, a.y, 1, kNow, a.color || (a.entityId!=null ? (entityColors.get(a.entityId)||null) : null));
                }
            }
            // 4) Trval√© kotvy (starty s tHide a konce s tHide)
            for(const a of anchorsPermanent){
                if(globalTime + 1e-6 >= a.t && globalTime < (a.tHide ?? Infinity) - 1e-6){
                    let near = false;
                    for(const p of drawnNow){ if(Math.hypot(p.x - a.x, p.y - a.y) < 14){ near = true; break; } }
                    if(!near) drawRoleCircle(a.role || 'F', a.x, a.y, 1, kNow, a.color || (a.entityId!=null ? (entityColors.get(a.entityId)||null) : null));
                }
            }
        }
        // Bez dodateƒçn√Ωch kotev ‚Äì zobrazuje se pouze aktivn√≠/posledn√≠ stav hr√°ƒçe
        if(totalDuration && globalTime >= totalDuration){
            // dokonƒçi ‚Äì ponech zobrazen√© fin√°ln√≠ ikony
            if(animationFrame) cancelAnimationFrame(animationFrame);
            animationFrame = null;
        }
    }

    function loop(ts){
        if(lastTimestamp == null) lastTimestamp = ts;
        const dt = (ts - lastTimestamp) / 1000; // v sekund√°ch
        lastTimestamp = ts;
        renderFrame(dt);
        animationFrame = requestAnimationFrame(loop);
    }

    function resetAnimation(){
        lastTimestamp = undefined;
        globalTime = 0;
    }

    // Ovl√°d√°n√≠
    function playAnimation(){
        if(animationFrame) return; // u≈æ bƒõ≈æ√≠
        if(paused){ paused = false; animationFrame = requestAnimationFrame(loop); return; }
        resetAnimation();
        animationFrame = requestAnimationFrame(loop);
    }
    function pauseAnimation(){ if(animationFrame){ cancelAnimationFrame(animationFrame); animationFrame = null; paused = true; } }
    function stopAnimation(){
        if(animationFrame) cancelAnimationFrame(animationFrame);
        animationFrame = null;
        paused = false;
        // po zastaven√≠ vyƒçisti pl√°tno (≈æ√°dn√° ikona ani puk na plo≈°e)
        drawBackground();
    }
    function restartAndPlay(){ stopAnimation(); prepareAnimation(); resetAnimation(); animationFrame = requestAnimationFrame(loop); }
    function setMode(m){ animMode = m; prepareAnimation(); }

    // Expose to buttons
    window.playAnimation = playAnimation;
    window.stopAnimation = stopAnimation;
    window.restartAndPlay = restartAndPlay;
    window.setMode = setMode;

    // UI binding
    document.addEventListener('DOMContentLoaded', () => {
        if(DEBUG) ensureDebugPanel();
        // Toolbar buttons (CSP-safe binding)
        try {
          const bPlay = document.getElementById('btnPlay');
          const bPause = document.getElementById('btnPause');
          const bStop = document.getElementById('btnStop');
          if(bPlay) bPlay.addEventListener('click', () => { try{ playAnimation(); }catch(_){} });
          if(bPause) bPause.addEventListener('click', () => { try{ pauseAnimation(); }catch(_){} });
          if(bStop) bStop.addEventListener('click', () => { try{ stopAnimation(); }catch(_){} });
        } catch(_) {}
        const sel = document.getElementById('animMode');
        if(sel){ sel.addEventListener('change', e => setMode(e.target.value)); }
        const chk = document.getElementById('showAnchors');
        if(chk){
            showAnchors = chk.checked;
            chk.addEventListener('change', () => { showAnchors = chk.checked; });
        }
        const pairSel = document.getElementById('pairMode');
        if(pairSel){
            pairSel.addEventListener('change', () => { pairMode = pairSel.value; prepareAnimation(); });
        }
        const syncSel = document.getElementById('syncOverride');
        if(syncSel){ syncSel.addEventListener('change', () => { syncOverride = syncSel.value; prepareAnimation(); }); }
        // Zoom controls
        const zi = document.getElementById('zoomIn');
        const zo = document.getElementById('zoomOut');
        const zr = document.getElementById('zoomReset');
        const zrng = document.getElementById('zoomRange');
        if(zi){ zi.addEventListener('click', () => { manualZoom = true; zoom = Math.min(MAX_ZOOM, zoom * 1.1); applyCanvasSize(); }); }
        if(zo){ zo.addEventListener('click', () => { manualZoom = true; zoom = Math.max(MIN_ZOOM, zoom / 1.1); applyCanvasSize(); }); }
        if(zr){ zr.addEventListener('click', () => { manualZoom = false; zoom = 1.0; applyCanvasSize(); }); }
        if(zrng){ zrng.addEventListener('input', () => { manualZoom = true; const v = parseInt(zrng.value,10) || 100; zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, v/100)); applyCanvasSize(); }); }
        updateZoomLabel();
        // Buttons are inside the debug panel toolbar; no extra setup needed here.

        // Autoplay support (?autoplay=1)
        try {
            const usp = new URLSearchParams(window.location.search);
            if(usp.get('autoplay') === '1'){
                // ensure animation is prepared before playing
                setTimeout(() => { try { playAnimation(); } catch(_){} }, 50);
            }
        } catch(_){}
    });
</script>
{% endblock %}
